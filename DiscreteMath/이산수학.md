<강의,워크북>
1	강의 소개 및 논리	2.1 명제 2.2 논리연산 2.3 술어논리 2.4 추론 (「2.1 명제 2.2 논리연산」 위주로 강의가 진행됩니다.)	2장		강의</br>
2	관계	6.1 기본사항 6.2 관계의 표현 6.3 관계의 성질 6.4 관계의 종류 (「6.2 관계의 표현. 6.3 관계의 성질」 위주로 강의가 진행됩니다.)	6장		강의</br>
3	함수	7.1 기본사항 7.2 전사, 단사, 역함수 7.3 함수의 종류 강의 내용 정리 (「7.3 함수의 종류」 위주로 강의가 진행됩니다.)	7장		강의</br>
출석수업평가	맞춤형평가	출석수업 내용 (2, 6, 7장)  	수업 당일     </br>
출석수업대체시험	온라인출석시험(객관식)	교재(2021) 1장~7장(해당 멀티미디어 강의 포함)   	5월 중    </br>     
형성평가	진도15/연습문제5	학습진도율 및 연습문제 	  </br>
기말시험	온라인출석시험(객관식)	교재 전체(해당 멀티미디어 강의 포함)    	6월 중      </br>  

cmd+k
### 목차
 #### [1. 이산수학의 개요](#이산수학의-개요)
 #### [2. 논리](#논리)
 #### [3. 증명](#증명)
 #### [4. 집합론](#집합론)
 #### [5. 행렬](#행렬)
 #### [6. 관계](#관계)
 #### [7. 함수](#함수)
 #### [8. 부울대수](#부울대수)
 #### [9. 그래프1](#그래프-1)
 #### [10. 그래프2](#그래프-2)
 #### [11. 트리](#트리)
 #### [12. 조합이론](#조합이론)
 #### [13. 정수론](#정수론)
 #### [14. 오토마타 및 형식언어](#오토마타-및-형식언어)
 #### [15. 종합정리](#종합정리)

---
# 이산수학의 개요
#### 학습목표
1. 이산적인 데이터와 연속적인 데이터를 구분할 수 있다.</br>
2. 문제 해결과정에 사용되는 용어들을 도구, 기법, 방법론으로 구분할 수 있다.</br>
3. 추상화의 의미를 이해할 수 있다.</br>
4. 알고리즘을 기술하기 위한 의사코드의 사용법을 이해하고 올바르게 사용할 수 있다.</br>

### 1. 이산수학이란
수학</br>
- 대수학 : 일차방정식, 선형대수, 미지수</br>
- 해석학 : 미적분, 복소수해석학</br>
- 기하학 : 유크리트(한 점에서 같은 거리에 위치한 점을 모두 모으면 원), 데카르트(해석기하학)</br>

수학</br>
- 연속수학 : 연속적인 집합의 그래프, 미분 (연속함수만 미분 가능)</br>
- 이산수학 : 이산적인 집합의 그래프</br>

### 2. 문제해결 = 도구, 기법, 방법론
- a. 도구 : 정의,정리 (예시: 축구공, 축구화, 축구장, 골대, 보호대, 유니폼)</br>
- b. 기법 : 가우스소거법(일차연립방정식),근의공식(2,3차 방정식) (예시:킥, 헤딩, 트래핑, 스토핑, 태클, 스로인, 골키핑)</br>
- c. 방법론 : 상황에 따라 효과적이고 호율적인 도구와 기법을 선택하는것 (예시:피라미드 시스템, 4-2-4 시스템, 토털사커, 수비시스템)</br>

#### 문제해결과정
- 수학적 모델링 : 문제 => 추상모델 => 변형된 모델 => 문제의 해결책</br>
- 정보 모델링 : 문제 => 정보 => 처리 => 문제의 해결책</br>

### 3. 추상화 abstraction
   - 일정한 인식목표를 추구하기 위해 여러가지 표상이나 개념에서 특정한 특성이나 속성을 빼냄</br>
   - 문제와 관련된 핵심내용만 남기고 관련없는 내용을 제거하여 문제를 단순화 시키는 과정
   - 문제: 과일가게 아저씨가 **사과 1개**를 **600원** 주고 사서 **800원**에 팔고, **배 1개**를 **1200원**주고 사서 **1500원**에 팔았다고 할 때, 사과와 배를 **합**하여 **총 10개**를 팔고 **이익**이 **2400원**이 생겼다고 한다면 사과는 몇 개 팔았을까?
   - 간단한 문제표현: **a** = 사과 판매 갯수, **b** = 배 판매 갯수, **a+b=10**, **200a+300b = 2400**

#### 디지털 논리 회로의 간소화 (제8장 부울대수)
 <img width="292" alt="Screenshot 2024-02-19 at 9 45 42 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/eaa14338-a701-4289-b18d-64661f2e2129"><img width="350" alt="Screenshot 2024-02-19 at 9 45 14 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/37f02880-b53c-4758-b630-fa0f048bbb2b"></br>
  and(*), or(+), -(~)</br>

  
  <img width="345" alt="Screenshot 2024-02-19 at 9 58 00 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/650b41e1-cdf7-4fd4-b5af-d75db35f8906">
  <img width="400" alt="Screenshot 2024-02-19 at 10 05 17 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/60c45164-25bd-401b-ba1c-497e2cfbd05e">

- 부울대수란 0과 1로만 쓰는 대수이기 때문에 연산순서가 무엇을 먼저하든 상관이 없기 때문에 곱하기,더하기의 연산순서가 같다.
- 곱하기(and), 더하기(or) 논리이기 때문에 연산순서가 상관이 없음.
- 분배법칙 : a(b+c) = ab + ac
a + bc = (a+b)(a+c)   부울대수에서는 a + bc가 분배법칙을 쓴 것처럼 결과값이 이렇게 나옴

- 이러한 추상화를 통해 간소화된 회로가 있다고 하면 입출력 결과는 같지만 회로는 X+Y로 훨씬 간소화 될 수 있다. 따라서 디지털회로를 간소화 하기 위해서는 부울대수를 배워야 한다.

### 4. 알고리즘
어떠한 문제를 해결하기 위한 여러 동작들의 유한한 모임
#### 알고리즘 표현방법
- a. 컴퓨터 프로그래밍 언어
  - 컴퓨터 작동을 위한 동작을 세밀하게 지시
  - 알고리즘의 핵심요소가 잘 드러나지 않음
  - 중요하지 않은 부차적인 표현에 신경써야 함
  - 통일된 언어가 존재하지 않음
- b. 순서도 (flowchart)</br>
  <img width="296" alt="Screenshot 2024-02-19 at 10 14 57 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/77e2a364-5af9-45ee-aa8b-61dac607e714"></br>
      - 장점: 알고리즘의 작동방식을 도식화함 (순차, 선택, 반복)
      - 단점: 내용이 복잡하거나 프로그램의 크기가 클 경우에 표현하기 어려움

```
start
read N = 3
M = 1, F= 1
F = F * M = 1 * 1 = 1
Is M = N?  (M=1, N=3) No
M = M + 1  (M = 1+1 = 2)
F = F * M = 1 * 2 = 2
Is M = N?  (M=2, N=3) No
M = M + 1  (M = 2 + 1 = 3)
F = F * M = 1 * 3 = 3
Is M = N?  (M=3, N=3) Yes
Print F (3)
End
```
- c. 의사코드(sudo code)
  - 모호한 부분은 프로그래밍 언어의 문법을 채용하여 명확하게 기술
  - 구체적으로 표현할 필요가 없는 부분은 자연어를 통해 설명식으로 기술
  - 알고리즘의 작동방식을 설명하는 용도로만 사용
 - C언어를 기반으로 하는 의사코드 사용

#### 할당문 k=100
#### 제어문
- 순차문 (sequence)

```python
 x <- 0;
x <- x + 1;
 x <- x + 2;
```
      
- 선택문 (selection) if, switch 문
```python
if(x > 0) print "pos";
else if ( x < 0 ) print "neg";
else print "zero";
```
```python
switch(x)
(
 case 0:
print '0';
break;
case 1:
print '1';
break;
default:
print 'I don't know the number';
break;
)
```
        
- 반복문 (iteration) for, while, foreach 문
- 54321fire 를 출력하는 동일한 코드
```python
for x <- 5 to 0
{
 print x;
}
 print "fire";
```
```python
x <- 5;
while x >= 0 do
{
 print x; 
x <- x - 1;
}
print "fire";
```
```python
foreach x in {5,4,3,2,1,0}
(
print x; 
)
print "fire";
```


### 5. 이산수학의 응용분야
  <img width="633" alt="Screenshot 2024-02-19 at 10 55 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/97de065b-ae89-430e-aa3a-ee18fde76f42">


1. 수학 분야 중 특히 디지털 컴퓨터가 데이터를 처리하는 과정에 필요한 수학적인 개 념과 원리를 배울 수 있는 것은 ( )이다.</br>
2. 컴퓨터는 아날로그 컴퓨터와 디지털 컴퓨터로 구분할 수 있는데, 처리하는 자료가 연속적인 형태라면 ( ) 컴퓨터라고 볼 수 있고, 처리하는 자료가 이산적인 형태라 면 ( ) 컴퓨터라고 할 수 있다.</br>
3. 수학의 정의와 정리들은 수학적 ( )로 볼 수 있다.</br>
4. 일차연립방정식을 풀 때 상황에 따라 대입법, 소거법, 또는 근의 공식을 활용할 수 있는데, 이 중 어떤 것을 사용할 것인지 선택하는 것이 수학적 ( )이라고 볼 수 있다.</br>
5. 수학적 모델링이나 정보 모델링은 ( )을(를) 통해서 진행되는데, 이것은 문제와 관련된 핵심내용만 남기고 관련 없는 내용을 제거하거나 문제를 단순화시키는 과정 이다.</br>
6. ( )이란 주어진 문제를 해결하기 위한 여러 동작들의 유한한 집합으로 정의된다.</br>
7. 알고리즘을 표현하는 언어로는 ( ), ( ), ( ) 등이 있다.</br>
8. ( )은(는) 프로그래밍 언어를 흉내 내어 작성한 코드를 말하며, 컴퓨터에서 실행 되지 않고, 사람에게 ( )의 작동방식을 설명하는 용도로만 사용된다.</br>
9. 의사코드에서 사용되는 ( )은 값을 저장하기 위한 구문으로, 우변의 값이 좌변에 저장된다.</br>
10. 의사코드에서 사용되는 제어문은 다시 ( ), ( ), ( ) 등으로 구분된다.</br>

 ==
1.이산수학 2. 아날로그, 디지털 3. 도구 4. 방법론 5. 추상화 6. 알고리즘 7. 컴퓨터 프로그래밍 언어, 순서도, 의사코드 8. 의사코드, 알고리즘
9. 할당문 10. 순차문, 조건문, 반복문

---


# 논리
#### 학습목표
1. 명제와 명제가 아닌 것을 구분할 수 있다.
2. 다양한 논리연산의 기능을 이해하고 합성명제의 진리값을 구할 수 있다.
3. 한정자가 포함된 술어논리를 구사할 수 있다. 
4. 두명제의논리적동치여부를판별할수있다.
5. 추론규칙을 이용하여 타당한 추론을 판별할 수 있다.

## 2.1 명제 : 참/거짓(진리값)을 구별가능한 문장,수학적 식 (e.g> x+2=0 은 명제함수)
   - 합성명제
   - 조건명제, 쌍조건명제
   - 항진명제, 모순명제
## 2.2 논리 연산
### 2.2.1 논리 연산자
#### 합성명제(compound proposition) : 하나 이상의 명제와 논리연산자들이 결합되어 만들어진 명제
 - 1) __논리합:(disjunction), or(또는), ⋁__ : 하나 이상의 참이 있을경우 참이 되고, 모두 거짓일 경우 거짓</br>
 - 2) __논리곱(conjuction), and(그리고), ⋀__ : 모두 참일 경우 참이 되고, 하나 이상의 거짓이 있을 경우 거짓</br>
 - 3) __부정(negation), not, ∼__ : 명제가 참일 경우 거짓, 거짓일 경우 참</br>
 - 4) __배타적 논리합(exclusive or; xor , ⊕)__ : 명제가 서로 다른 진리값을 가지면 참, 동일한 진리값을 가지면 거짓 (e.g>or연산에서 참/참 인 경우와 거짓/거짓 인 경우만 반대로 T T => F, F F => T, T F /F T => T)
             __p⊕ q = (p⋀～q)⋁ (～p⋀ q)__</br>

 ### 2.2.2 조건명제(conditional proposition, 함의(implication):어떤 사실의 인과관계를 나타내는 명제
 - p → q : p, q가 명제일때, p가 조건, q가 결론의 역할
 - 조건이 참이고 결론이 거짓일 경우만 유일하게 __거짓__ 이 되고, 나머지 세가지 경우 참 
 - 조건이 거짓일 경우 결론이 어느 쪽이 되더라도 조건명제를 거짓이라 볼 수 없어, 참이라 간주한다.
 - 예) 선생님: 내일 비오면 휴강이다
 - 1. 비 올 경우 ( 휴강하면 T, 휴강x F)
   2. 비 안 올 경우 (휴강하던 안 하던 애초에 언급하지 않아서 선생님말 거짓이라 볼 수 없어 참으로 간주)
     
 - 충분조건(sufficient condition)/필요조건(necessary condition)
   - p은 q의 충분조건 : p, q가 명제일때 “if r, then s” (p가 일어나면 항상 q가 일어나는 것을 보장한다.)
   - q는 p의 필요조건 : p, q가 명제일때 “if not r, then not s” (q는 p가 일어나는데 필요하다.)
  
<img width="683" alt="Screenshot 2024-04-02 at 2 36 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1af03622-0e07-469e-9c69-8c95b2a5db48"></br></br>

     
 - __쌍조건명제(biconditional proposition)__:명제 p, q가 있을때, 명제 p와 q가 조건의 역할과 결론의 역할을 동시에 수행한다</br>
            __p ⟷ q = (p → q)⋀(q → p) = ~(p ⊕ q)__
   - p는 q이기위한 필요충분조건 : “p if and only if q" 
   - p, q가 동시에 동일한 진리값을 가지면 참, 서로 다른 진리값을 가지면 거짓 ( __배타적 논리합의 부정과 같음 ~( p ⊕ q )__ )
  
     

 ### 2.2.3 동치
 - 논리적 동치(logical equivalence)
   * ① 동치 : p ≡ q
     - 명제 p와 q가 논리적으로 동등, 즉 항상 동일한 진리값을 가질때
     - 쌍조건명제와 같은 의미
   * ② 역/이/대우 :
     - 조건명제 p→ q에 대해서,
       - 역(converse) : q→ p
       - 이(inverse) : ～p→ ～q
       - 대우(contrapositive) : ～q→ ～p
     - 조건명제와 그의 대우는 서로 논리적 동치관계이다
   * ③ __논리적 동치법칙 = 항진명제__ </br>
<img width="342" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/1118714e-2e01-4bf3-91dc-7960617f0a37"></br>   
   * ④ 항진명제(tautology) : 항상 참인 명제 (e.g> P v T )</br>
     모순명제(contradiction) : 항상 거짓인 명제 (e.g> P ⋀ F )
   * ⑤ 연산자의 우선순위 : ～, ⋀⋁, →⟷, ≡

## 2.3 술어논리
### 2.3.1 술어논리와 명제함수
#### 술어논리(predicate logic)
    * 술어 : 주어의 동작, 상태, 성질에 대해 서술하는 말
    * 술어논리 : 술어를 중심으로 그에 딸린 주어를 나열하는 형태로 표현한 문장
      "소크라테스는 사람이다” ⇒ 사람(소크라테스)
    * 명제논리에서는 명제 단위의 참, 거짓에만 관심을 가지기 때문에 새로운 사실을 추론할 수 없다.
    * 술어논리에서는 주어와 술어 사이에 더욱 세밀한 표현을 할 수 있어 다양한 사실을 찾을 수 있다.

- 명제함수(propositional function)
   - 명제함수 : 변수의 값에 의해 함수의 진리값이 결정되는 문장 (e.g> x + 2 = 0 __명제가 아닌 명제함수__)
   - 명제함수를 명제로 만들기
     - ① 각 변수에 특정한 값을 부여하거나 (예: 명제함수 p(x,y)가 x^2+y^2=4 일때 p(1,2)의 진리값은? F)
     - ② 한정자를 사용해 변수의 값을 제한 
         - 전체한정자(universal quantifier), "모든for All"또는 "임의의Arbitrary"  ∀
         - ∀ x P(x) : 정의역의 __모든 [임의의] x__에 대하여 P(x)가 참(T)임을 의미한다. 
         - 존재한정자(existential quantifier), 존재한다, ∃
         - ∃ x P(x) : 어떤 x에 대하여 P(x)는 참이다. 하나 이상의 x에서 참이라면 참이 된다.
         - 한정자의 부정 :
         - ～∀xP(x) ≣ ∃x～P(x)
         - ～∃xQ(x) ≣ ∀x～Q(x)

### 2.3.2 타당성 검사
 - 벤다이어그램(Venn diagram): 한정자가 사용된 명제함수의 타당성을 직관적으로 검사함
 - 삼단논법 (예: 영희는 서울에 있다, 서울은 한국에 있다, 영희는 한국에 있다)
## 2.4 추론
- 1) 추론(inference) :
  - 참으로 알려진 명제를 기초로 하여 다른 명제를 유도해 내는 과정
  - 하나 이상의 전제(premise,이미 알려진 명제)와 하나의 결론(conclusion,새로 유도된 명제)으로 구성
- 2) 유효추론 :
  - 전제를 참(T)이라고 가정 했을때, 그에 따른 결론이 항상 참(T)이 되는 추론</br>
    예: ((p->q)⋀(q->r))->(p->r) 삼단논법       
- 3) 추론규칙 : 기본적 추론규칙은 논리적 동치(항진명제)를 이용함
<img width="416" alt="Screenshot 2024-02-25 at 12 10 02 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/fb0206c4-63f8-4cdb-b2ec-5821bc32fbf3">
<img width="416" alt="Screenshot 2024-02-25 at 12 10 10 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/ebb3985c-0b7b-45cc-a6d8-1c6635f5ad34">

---

# 증명
## 기본사항
### 1. 증명
1) __공리(axiom [ӕksiəm], 公理, 자명한 이치)__ : (어떤 다른 명제들을 증명하기 위해 전제로 사용되는) 가장 기본적인 가정으로, 별도의 증명없이 참으로 이용되는 명제
(예)
- 두 점이 주어졌을때, 두 점을 통과하는 직선을 그릴 수 있다. (유클리드 기하학)
- 어떤 자연수도, 그 수의 다음 수가 존재한다. (페아노의 공리)
- 어떤 것도 포함하지 않는 집합이 존재한다. (공리적 집합론)
3) __증명(proof)__ : 특정한 공리들을 가정하고, `그 가정하에` 제안된 명제가 `참`임을 입증하는 작업
4) __정리(theorem [θi:ərəm]) (not 정의)__ : 공리로부터 증명된 명제
   - 보조정리(lemma) : 정리를 증명하기 위한 과정 중에 사용되는 명제 (예: 큰 명제를 증명하기 위한 작은 명제 증명)
   - 따름정리(corollary) : 정리로부터 쉽게 도출되는 부가적인 명제 (예: 정리가 잘 되어있어 조금 변형해서 또 다른 정리 도출)
    - (예) 임의의 직각삼각형에서 빗변을 한 변으로 하는 정사각형의 넓이는 다른 두 변을 각각 한 변으로 하는 정사각형의 넓이의 합과 같다. (피타고라스의 정리)
    - n이 2보다 큰 자연수일때, xn+yn=zn 방정식을 만족하는 0이 아닌 정수해(x,y,z)는 존재하지 않는다. (페르마의 마지막 정리)
      소수는 무한히 많다. (유클리드 정리)

## 증명기법

### 1.직접증명법(direct proof, 연역법) :
 - 공리와 정의, 정리를 논리적으로 직접 연결하여 증명한다.
 - 명제를 변형하지 않고 증명
 - 주로 공리와 정의, 그리고 이미 증명된 정리를 논리적으로 직접 연결해 증명하는 형식.
 - 연역법: 이미 증명된 하나 또는 둘 이상의 명제를 전제로 하여, 새로운 명제를 결론으로 이끌어내는 것.
 - (예)
 - 두 짝수의 합은 항상 짝수임을 증명하라.
 - 정수 a,b,c가 b는 a로 나누어지고 c는 b로 나누어질 경우, c는 a로 나누어짐을 증명하시오.
 - a,b가 실수일 경우 a2 + b2 ≥ 2ab 임을 증명하시오.
 - 두 유리수의 합이 실수임을 증명하시오.
```
두 홀수의 합은 짝수임을 증명하라.
두 홀수를 각각 𝒙, 𝒚 라고 하자.
두 홀수의 합은 짝수임을 증명하라. (정수에 2배 한 것은 정수)
⇒ 𝒙 = 𝟐𝒂 + 𝟏, 𝒚 = 𝟐𝒃 + 𝟏 (단,𝒂,𝒃는정수) 
⇒ 𝒙 + 𝒚 = 𝟐𝒂 + 𝟏 + 𝟐𝒃 + 𝟏 = 𝟐(𝒂 + 𝒃 + 𝟏) 
여기서 𝒂 + 𝒃 + 𝟏 은 정수이므로
∴ 𝒙 + 𝒚 도 짝수. ■
```

두 유리수의 합이 유리수임을 증명하라.</br>
<img width="526" alt="Screenshot 2024-03-14 at 3 51 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0cbf387b-bc8a-4bb2-97e0-e92d0138c568">

파스칼 삼각형</br>
<img width="526" alt="Screenshot 2024-03-14 at 3 54 37 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/905b7d2c-e645-4fe2-b237-a837f0e40704">

<img width="310" alt="Screenshot 2024-03-14 at 3 55 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b45e2bb8-d3af-430f-b35d-f7ece5492379"> <img width="300" alt="Screenshot 2024-03-14 at 3 56 01 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b9e3de5c-c85a-49a7-9527-ca8bc3fbaa1f">



### 2.수학적 귀납법(proof of mathematicsal induction) :
- 기본단계, 귀납가정, 귀납단계를 이용해 모든 자연수n에 대한 명제의 성질을 증명하는데 유용
- ① 기본단계(basic) : n = 1 일때 명제가 참임을 증명
- ② 귀납가정(inductive assumption) : n = k 일때 성립한다고 가정
- ③ 귀납단계(inductive step) : n = k + 1 일때도 마찬가지로 성립함을 보이는 것
- (예) 모든 양의 정수 n에 대하여 2n>n임을 증명하시오.
  n이 자연수일때 n2+2n이 3의 배수임을 증명하시오.
  n이 자연수일때 n(n+1)(2n+1)이 6의 배수임을 증명하시오.
  𝒏 ≥ 5인 자연수에 대해 2ⁿ ≥ 𝒏²가 성립함을 수학적 귀납법으로 증명하시오. (퀴즈)
  
<img width="300" alt="Screenshot 2024-03-14 at 3 58 46 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a5edac76-4a23-489f-a71d-ce867325cdee"> <img width="370" alt="Screenshot 2024-03-14 at 3 59 44 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/85401ade-e806-480b-b93f-69115256f78e">




### 3.간접증명법(indirect proof) :
- 증명하기 쉬운 형태로 변형하여 증명하는 방법
- ① __대우증명법(proof by transposition)__ : P→Q <=>～Q→～P 
  (예)
  - x2이 짝수라면 x도 짝수임을 증명하시오.
  - a와 b가 서로소이면, a+b와 b도 서로소 임을 증명하시오.
  - m + n 이 무리수이면, 적어도 m,n 둘 중 하나는 무리수임을 대우증명법으로 증명하시오(퀴즈)
           
- ② __모순증명법(proof by contradiction)__ :  P→～Q를 증명할 때 ~ P를 가정하면 모순이 발생함을 보임
- 다른이름: 귀류법, 배리법
  (예) √2 가 무리수임을 증명하시오.

  <img width="458" alt="Screenshot 2024-03-14 at 4 07 02 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f5d3c812-226f-499b-b425-37f7c1eaac0f">

  
- ③ __반례증명법__ : 한정자(quantifer)가 포함된 명제의 증명
- 전체한정자(∀)가 사용된 명제가 거짓임을 증명 -> “(3) 반례증명법”
- 존재한정자(∃)가 사용된 명제가 참임을 증명 -> “(4) 존재증명법” (구성적 존재증명법, 비구성적 존재증명법)
  (예)
  - 모든 양의 실수x에 대해 x2>x 가 거짓임을 증명하시오.
  - 모든 실수 a,b에 대하여 a2=b2이면 a=b 가 거짓임을 증명하시오.
  - 모든 실수 ɑ에 대해 (ɑ+1)²≥ ɑ²가 성립하는지 반례 증명법으로 증명하시오.(퀴즈)</br>
    <img width="450" alt="Screenshot 2024-03-14 at 4 11 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/5907e795-759d-4923-8ecc-05dcfdf8d9df">

- ④ __존재증명법__ : (명제에 존재한정자가 사용되었을 경우) 해당 명제가 참임을 보이기 위해 특별한 예를 보임
   - 구성적 존재증명법 :
     명제함수 ∃𝒙𝑷(𝒙)를 증명할 때 𝑷(𝒙)를 참으로 만드는 𝒙를 찾거나 찾는 과정을 제시함
     (예) 두 개의 소수의 합으로 나타낼 수 있는 소수 n이 존재함을 증명하시오.
     ab이 무리수가 되는 유리수 a, b가 존재함을 증명하시오.
     ab이 유리수가 되는 무리수 a, b가 존재함을 구성적인 방법을 사용해 증명하시오.
     233+1이 합성수임을 증명하시오.</br>
     <img width="450" alt="Screenshot 2024-03-14 at 4 12 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e499bddf-600e-4daf-8cdb-ddedc2b63d34">

  - 비구성적 존재증명법 :
  - 명제함수 ∃𝒙𝑷(𝒙)를 증명할 때 𝑷(𝒙)를 참으로 만드는 𝒙 를 찾지 않고 우회적으로 명제가 타당함을 보이는 방법
    (예) ab이 유리수가 되는 무리수 a, b가 존재함을 증명하시오.
    <img width="508" alt="Screenshot 2024-03-14 at 4 13 20 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/5bbd985c-7682-4fbe-8b10-5a8ebca13731">


### 기타 증명법
- ① __전수증명법(proof by exhaustion)__ : 일일이 모든 경우의 수를 조사하는 방법(유도되는 경우의 수 적을때)
  (예) n이 5이하의 자연수 일때 (n+1)2 ≥ 2n임을 증명하시오.
  <img width="536" alt="Screenshot 2024-03-14 at 4 14 14 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8ae8d30e-af41-4bb2-ac61-8dcdb990248b">

- ② __조합적 증명법(combinatorial proof)__ : 두 집합의 원소의 개수가 동일하다는 것을 증명할때 사용
  - 전단증명(bijective proof) : 원소가 n개인 집합 A와 원소가 m개인 집합 B를 찾은후, 두 집합이 일대일 관계임을 보임 (서로 다른 집합에 있어 1:1 대응이 있다는 말)
  - 중복산정(double counting) : 동일한 집합의 원소를 서로 다른 두가지 방법으로 센 다음, 각각의 결과값인 n과 m이 같다는 것을 보임(하나의 집합에 대해 두가지 방법 적용)
- ③ __컴퓨터를 이용한 증명(computer-assisted proof)__
  (예) 4색정리에 대한 증명
  cf. 4색정리 : 평면을 유한개의 부분으로 나누어 각 부분에 색을 칠할때, 서로 맞닿은 부분을 다른 색으로 칠한다면 네가지 색으로 충분하다.

  
---


# 집합론 

## 1. 기본사항
1) __무정의 용어__ :
   - 직관적으로 이해할 수 있어서, 정의 없이 사용하는 용어
   - 집합(set), 원소(element)
2) __집합(menge)__ :
   - 우리의 직관이나 사고로부터 한정적이고 분리될 객체들을 수집해 놓은 것
  ① a∈S : S가 하나의 집합을 나타내고 a를 S의 원소라고 할때
  ② a∉S : a가 S의 원소가 아닐때
  ③ {a,b,c} : a,b,c를 원소로 가지는 집합
  ④ |S| : 집합 S의 원소의 개수
3) __집합의 서술__
 - `원소나열법`
 - `조건제시법` : {x | x는 0이 아닌 자연수}
4) __부분집합(subset)__ :
   A⊂B : 어떤 집합 A의 모든 원소가 집합 B에 포함될때, A는 B의 부분집합
   A=B, 상동(equal) : A가 B의 부분집합이고 B가 A의 부분집합
   __진부분집합(proper subset)__ : A가 B의 부분집합이지만 A≠B인 경우 (B가 더 큰 부분이 있어야 하고 A는 B를 포함하지 않음)
   ∅, { }, 공집합 : 원소가 하나도 없는 집합, 공집합은 모든 집합의 부분집합으로 약속한다.
5) __서로소__
- 서로소(disjoint) : A∩B=∅, 집합 A와 B가 공통된 원소를 가지고 있지 않다.
- __쌍으로 서로소__ : i≠j일때, Ai∩Aj=∅
  n개의 집합 A1,A2,⋯,An 이 있을때, 서로 같지 않은 임의의 두 집합 Ai와 Aj가 공통된 원소를 가지고 있지 않다.
6) __분할(partition)__ :
  하나의 전체집합을 __공집합이 아니면서__ 서로 __중복되지 않은 부분집합들__(서로소인 부분집합들)로 나누는 작업.
  분할후 부분집합들은 __쌍으로 서로소__ 이며, 이들 원소들의 합은 본래의 전체집합이 된다.
  [주의] 모든 원소가 하나씩은 있어야 한다!

<img width="300" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/80702453-b66b-4bb1-9d8c-1021a7a502b1"></br>
- 분할은 집합기호로 써야 함
- 분할은 여러개
- 공집합이 아니어야 함
- 교집합이 공집합이어야 함
- 부분집합의 합은 전체집합이 되어야 함
- 모든 분할 구하라고 하면  trivial partition 포함해야함 (자신을 부분집합으로 가지는 집합)

7) __P(A), 멱집합(power set)__ :
   임의의 집합에서 발생할 수 있는 모든 부분집합을 원소로 하는 집합
   집합 S가 n개의 원소로 이루어진 집합이라면 멱집합의 원소의 개수는 2의 n승 개 이다.
   [주의] 멱집합은 공집합을 원소로 포함한다!

## 2. 집합 연산
1) 합집합(union) : A∪B = {x∈U | x∈A⋁ x∈B}
2) 교집합(intersection) : A∩B = {x∈U | x∈A⋀ x∈B}
3) 차집합(difference) : A-B = {x∈U | x∈A⋀ x∉B}
4) `대칭차집합(symmetric difference)` : A ⊕ B = {x∈U | x∈(A∪B)⋀ x∉(A∩B)}</br>     <img width="200" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/c8420097-da68-434c-a784-0b9d6f9c6699"></br>
5) 여집합(complement,보집합) : Ac = {x∈U | x∉A}
6) 곱집합 (Cartesian product) : 순서쌍(a,b)들의 집합을 A,B의 곱집합, A x B = {(a,b)|a∈A,b∈B} 예시:A ={1,2} B = {a,b} 라고 할때 AxB는 {(1,a),(1,b),(2,a),(2,b)} 


## 3. 집합의 대수법칙
1) 합집합의 크기 : A,B가 유한집합일때 |A∪B| = |A| + |B| - |A∩B|
2) 포함관계의 이행성 : 만약 A⊂B이고 B⊂C이면, A⊂C이다.
3) 원소논증(element argument) : 하나의 집합이 다른 집합의 부분집합임을 증명하기 위해 원소의 포함관계를 이용하는 증명방식

<img width="400" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/9a6a73c1-c771-411d-9348-9e863992869c"></br>


<img width="400" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/c33245e1-ca19-4dfe-be98-10e750b42fa6"></br>


---

# 행렬
## 1. 행렬
1) m×n 행렬 :
- m, n이 양의 정수일때, 다음과 같이 m개의 행과 n개의 열로 구성된 직사각형 배열 A, 대괄호 기호로 묶어서 표현
- 행렬의 ( i , j )원소 : aij, A행렬의 i번째 행의 j번째 열의 수
           
2) 행벡터, 열벡터 : 하나의 행 혹은 하나의 열을 가진 행렬
3) 영행렬(zero matrix) : 모든 원소가 0인 행렬

<img width="428" alt="Screenshot 2024-03-29 at 11 51 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e1b44310-1717-4645-9d46-0879d25957a4">

## 2. 행렬의 연산
### 1) 기본연산
  행렬 __크기가 같은__ A, B가 있고 k를 실수라 할때,
- 행렬의 합 : A+B는 같은 위치의 A와 B의 원소를 각각 더한다. ( i , j )원소의 값은 a<sub>ij</sub> + b<sub>ij</sub>
- 행렬의 차 : A-B는 같은 위치의 A와 B의 원소를 각각 뺀다. ( i , j )원소의 값은 a<sub>ij</sub> - b<sub>ij</sub>
- 행렬의 스칼라 곱 : kA는 A의 각 원소에 k를 곱해서 구한다. ( i , j )원소의 값은 ka<sub>ij</sub>
  행렬의 모든 원소에 k를 곱해줌 예시) v =(1,2) `스칼라3 곱하기` 3v =(3,6)
    
### 2) 행렬의 합과 스칼라 곱의 연산법칙

<img width="431" alt="Screenshot 2024-03-29 at 11 59 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/900affdf-0f4a-4ea2-a5aa-c8cd25df9a61">

<img width="411" alt="Screenshot 2024-03-29 at 11 59 08 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1b57a232-51ac-4cb1-9e91-fe452a711c90">

         
### 3) 행렬의 곱

- 행렬A의 열개수와 행렬B의 행개수가 같아야 한다
- 교환법칙이 성립하지 않는다

<img width="468" alt="Screenshot 2024-03-30 at 12 01 14 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/6902cd81-4d04-4e43-86cb-7365f194c789"></br>
   
<img width="411" alt="Screenshot 2024-03-30 at 12 02 28 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/6dd6bce1-2ea3-4bdf-a483-39ac063091e0"></br>

<img width="679" alt="Screenshot 2024-03-30 at 12 03 47 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/fbdacabb-263c-4e65-8f3f-f7ced22d3e2d"></br>


<img width="602" alt="Screenshot 2024-03-30 at 12 05 18 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/c0bf185d-1b8e-4980-84f3-ebb499d39ebb"></br>


### 4) 행렬 곱의 연산법칙

<img width="433" alt="Screenshot 2024-03-30 at 12 08 15 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/a32e613e-77af-4ada-a545-154cfc0f5e35"></br>

<img width="519" alt="Screenshot 2024-03-30 at 12 09 03 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/112ae048-2ab6-4f83-8d3a-94f9d0d6c92c"></br>

<img width="600" alt="Screenshot 2024-03-30 at 12 10 38 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/6808aab1-c411-4578-8433-8d8c0695d64f"></br>

<img width="572" alt="Screenshot 2024-03-30 at 12 11 56 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/4995befb-cebb-4404-833b-1a9ff54d3865"></br>

        
### 5) 가우스 소거법(Gauss elimination)
#### 정의

<img width="616" alt="Screenshot 2024-03-30 at 12 14 06 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/ef3fed8a-c6ab-410d-b0bf-adfb38ab5b34"></br>


  - 일차연립방정식을 행렬과 벡터를 이용해 표현
    - 계수행렬(coefficient matrix), 미지수행렬,해(solution), 상수행렬(constant matrix)
    - 계수행렬과 상수행렬을 묶어 확대(확장)행렬(augmented matrix)로 표현할 수 있다.
    
#### 기본행연산 : 내용과 행렬연산예시 더 찾아보기                  
  - 행 교환(row interchange) 연산 : 두 행의 위치를 서로 바꾸는 작업 (R<sub>ij</sub>)
  - 행 스케일링(row scaling) 연산 : 하나의 행에 0이 아닌 스칼라 곱을 하는 작업 (R<sub>i</sub>(c)) c: 0이 아닌 상수
  - 행 대체(row replacement) 연산 : 하나의 행에 스칼라곱을 해서 다른 행에 더하는 작업(R<sub>ij</sub>(c))

<img width="467" alt="Screenshot 2024-03-30 at 12 21 20 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/38dca003-723b-43fd-a0d5-f38a6089b685"></br>

<img width="378" alt="Screenshot 2024-03-30 at 12 21 46 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/bdc7a834-27fa-4307-9a6d-8d05914f1341"></br>

#### 행제형 행렬(row echelon matrix)

<img width="568" alt="Screenshot 2024-03-30 at 12 23 17 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/3311c85a-9cc7-41c3-9ccf-65773d321d6f"></br>

<img width="602" alt="Screenshot 2024-03-30 at 12 23 47 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/6486dca2-8af4-428d-bb71-1263a7a9ee55"></br>

 - 확장행렬을 행사다리꼴로 만들고, 그 다음 기약 행사다리꼴로 변환해야 한다

 - 가우스 소거법 :
   - 행렬에서 가장 왼쪽의 0이 아닌 열을 선택하고, 해당 열의 첫번째 원소의 위치를 피벗(pivot) 위치로 표시
   - 아래의 행과 위치교환을 함으로써 피벗 위치에 해당 열에서 0이 아닌값을 위치시킨다. 1이 아니라면 행 스케일링 연산을 이용해 1로 만든다
   - 피벗 위치 아래의 원소의 값을 행 대체 연산을 통해 모두 0으로 만든다
   - 피벗 위치가 있던 행을 처리된 상태로 표시하고, 그 밑의 행에 대해서 과정을 반복
   - 행사다리꼴 행렬을 기약 행사다리꼴 행렬로 변환한다
  
<img width="502" alt="Screenshot 2024-03-30 at 12 26 58 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/49b1e7e6-7981-4164-b31a-b43b7639bf54">

<img width="559" alt="Screenshot 2024-03-30 at 12 28 09 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/b5b93b89-7082-4c86-9fa9-c09de277f6b7">

 <img width="503" alt="Screenshot 2024-03-30 at 12 28 56 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/e5ba68b6-64e3-4a8f-8cfc-4a8fd5656274">
 
<img width="557" alt="Screenshot 2024-03-30 at 12 31 50 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/8282777a-ad8f-46f5-99fe-c1616284619e">


## 3. 행렬의 종류
1) __정방행렬(square matrix)__ : 
   - 행과 열의 수가 같은 n×n 행렬 : n차 정방행렬
   - n을 정방행렬의 차수(order)라 함.
   - 대각원소(diagonal entry): 정방행렬의 a<sub>11</sub>,a<sub>22</sub>,..a<sub>nn</sub> 원소
   - 주대각선(main diagonal): 대각원소를 포함하는 대각선

2) __단위행렬(unit matrix)__ : 
   - n차 정방행렬에서 __주대각원소가 모두 1__ 이고 __나머지 원소는 모두 0__ 인 행렬
   - i=j 이면 a<sub>ij</sub> = 1 이고, i≠j 이면 a<sub>ij</sub> = 0 이다
   - 단위행렬은 스칼라행렬 중에 대각원소가 모두 1이고, 나머지는 다 0인 것

3) __대각행렬(diagonal matrix)__ : 
   - n차 정방행렬에서 __주대각원소 이외의 모든 원소가 0__ 인 행렬 
   - 시험 : 3차 전방행렬인 영행렬주고, 대각원소 빼고 모두 0이니 대각행렬임
   - 시험: 스칼라매트릭스 대각행렬임 a<sub>ii</sub> 의 값이 모두 같음. 대각행렬중에 스칼라행렬이라고 함.

4) __대칭행렬(symmetric matrix)__ : 
  - n차 정방행렬에서 a<sub>ij</sub> = a<sub>ji</sub> 인 행렬
  - 주대각선을 기준으로 대칭인 행렬

<img width="551" alt="Screenshot 2024-03-30 at 12 43 23 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/f16acbfb-3d50-423f-bfcd-f003d525d978"><br>
 
5) __역대칭행렬 (skew symmetric matrix)[교대행렬]__ : 
  - n차 정방행렬에서 a<sub>ij</sub> = -a<sub>ji</sub> 이고 대각원소가 모두 0인 행렬
  - i=j 이면 a<sub>ij</sub> = 0 이고, i≠j 이면 a<sub>ij</sub> = -a<sub>ij</sub> 이다

<img width="517" alt="Screenshot 2024-03-30 at 12 51 07 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/3fafcfca-8b2c-4060-b328-cf8f4c7fc7c7"></br>


6) __삼각행렬(triangular matrix)__ : 
   - n차 정방행렬에서
   - 상삼각행렬(upper) : 주대각선 아래에 있는 모든 원소들이 0인 행렬 (아랫쪽 0이니 위쪽에 정보있음)
     - i > j일때 a<sub>ij</sub> = 0
   - 하삼각행렬(lower) : 주대각선 위에 있는 모든 원소들이 0인 행렬
     - i < j일때 a<sub>ij</sub> = 0
   - 삼각행렬 : 상삼각행렬 또는 하삼각행렬

  <img width="584" alt="Screenshot 2024-03-30 at 12 55 19 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/bbcabb79-e7af-436d-b4f4-28ffe9510f38"></br>

     
7) __전치행렬(transpose matrix)__ : 
   - m×n 크기의 행렬 A가 주어졌을때, A의 행과 열을 서로 교환한 행렬

<img width="495" alt="Screenshot 2024-03-30 at 12 56 30 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/c2dd7113-e029-43bf-8e56-dba8e46fa9bd"></br>

<img width="492" alt="Screenshot 2024-03-30 at 12 57 18 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/ff52a90d-593a-4786-9744-48e6a078eb6f"></br>

8) __역행렬 (inverse matrix)__ :

<img width="546" alt="Screenshot 2024-03-30 at 12 58 57 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/f88fabbc-9e99-49ce-932b-459ed831d1e9">

### 4.부울행렬 (boolean matrix)
1) 정의: 행렬의 모든 원소가 부울값(0 or 1)으로만 구성된 행렬
2) 기본 연산 (중요) :합,교차,부울곱
   크기가 m x n 인 두 행렬 A = [a<sub>ij</sub>] 와 B = [b<sub>ij</sub>] 가 부울행렬일때,
   - __합(join)__ : A ∨ B = (i,j)원소가 a<sub>ij</sub> ∨ b<sub>ij</sub> 이고, 크기가 m x n 인 부울행렬 C이며, C = A ∨ B 로 나타낸다. (같은 위치의 요소끼리 or 연산을 하라는 것임
덧셈이니 결과값 행렬크기도 같음)
   - __교차(meet)__ :  A ∧ B = (i,j)원소가 a<sub>ij</sub> ∧ b<sub>ij</sub> 이고, 크기가 m x n 인 부울행렬 C이며, C = A ∧ B 로 나타낸다.  
   - __부울곱(product)__ : (i,j)원소가 다음과 같이 정의되는 크기가 m x l 크기의 부울행렬 C이며, C = A ⊙ B 로 나타낸다. (행렬곱이랑 같다고 생각하면 됨)
   - c<sub>ij</sub> = (a<sub>i1</sub> ∧b <sub>1j</sub>)∨(a<sub>i2</sub> ∧ b<sub>2j</sub>)∨…∨(a<sub>in</sub> ∧ b<sub>nj</sub>)
   
<img width="528" alt="Screenshot 2024-03-30 at 1 11 50 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/afbce810-fc99-4ff9-bd02-3787a890c771">





---

# 관계
## 기본사항
집합 A와 B의 곱집합 A x B 는 A 의 원소와 B의 원소의 모든 순서쌍(ordered pair)들의 집합. 즉, A x B = {(a,b)|a ∈ A, b ∈ B}
관계(relation) : 두 집합 X 와 Y가 존재하고 X __에서__ Y __로의__ `(이항)관계 R`이 있을때, R은 이들의 __곱집합 X x Y__ 의 __부분집합__ 이다.
- __(x,y) ∈ R__
- x는 y와 R의 관계가 있다
- xRy로 표기
- X 에서의 관계 : 두 집합 X, Y가 X = Y를 만족할때 이들 사이의 관계 R (x에서 x로 가는 관계이기 때문에 y로의 라는 표현이 없음)
- R = { (a,b) | (a,b) ∈ R, aR, bR }

## 관계의 표현
### 화살표 도표
<img width="400" alt="Screenshot 2024-03-18 at 3 27 57 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b37bf388-c293-4056-abca-82215e95da7c"></br>

<img width="450" alt="Screenshot 2024-03-18 at 3 29 54 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/70de1b8e-84ec-439f-b463-e3ef0b1e8899"><img width="400" alt="Screenshot 2024-03-18 at 8 10 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4716d75e-0d36-46f8-a699-ab2a50ed4a22"></br></br>

### 방향그래프
<img width="500" alt="Screenshot 2024-03-18 at 3 32 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a456b951-0c2b-412a-836a-f5859dd23a6a"></br></br>

<img width="500" alt="Screenshot 2024-03-18 at 3 33 17 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0db1b3d7-4d87-4beb-b04b-3571cf6b17e3"></br></br>


### 부울행렬
<img width="500" alt="Screenshot 2024-03-18 at 3 39 37 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ad76ff76-ce8f-4ec6-a8da-0934e8c6dad6"></br></br>
  
<img width="500" alt="Screenshot 2024-03-18 at 3 39 59 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/3a14003c-e96f-4dff-88f5-d073f106e9c5"></br></br>

## 관계의 성질 (중요!!!)
- 반사적, 대칭적, 추이적
  
<img width="499" alt="Screenshot 2024-03-18 at 4 30 23 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/95d14c13-cd8c-4cf9-9a50-7ab37ec6be35"></br></br>

### 1. 반사적(reflecxive): ∀a ∈ A, (a,a) ∈ B (나와의 관계)
- 모든 a∈R 에 대해 aRa 가 성립하는 경우 관계 R, 자기 자신과 관계를 가져야 한다
- __부울행렬로 표시하였을때, 주대각요소가 1이다__
  
 <img width="322" alt="Screenshot 2024-03-18 at 4 35 12 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/5d2d3e30-1ba5-4862-90de-6e6398b3418c"></br></br>
 
### 2. 대칭적(symmetric) : ∀a,b ∈ A,   (a,b) ∈ R => (b,a) ∈ R (다른사람과의 관계)
- 모든 a,b∈R 에 대해 aRb→ bRa 가 성립하는 경우 관계 R, 모든 관계가 대칭되는 관계를 가져야 한다. (자기 자신과의 대칭관계도 포함 가능)
- 부울행렬로 표시하였을때, aij = bji 이다
  
 <img width="377" alt="Screenshot 2024-03-18 at 4 35 31 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/469140b6-1434-4559-b6cc-5eb6b5cf2667"></br></br>

### 3. 추이적(transitive) :∀a,b,c ∈ A,   (a,b) ∈ R  ⋀ (b,c) ∈ R => (a,c) ∈ R
- 모든 a,b,c ∈ R 에 대해 (aRb ⋀ bRc) → aRc 가 성립하는 경우 관계 R
  
<img width="550" alt="Screenshot 2024-03-18 at 4 35 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a96af8b5-75c9-476a-ac1a-e5676def0a99"></br></br>

#### 추이적이 아닌 예시
  
<img width="451" alt="Screenshot 2024-03-18 at 4 39 20 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d5c4b12d-e303-4c88-a2f9-5188c7c24d49">
<img width="450" alt="Screenshot 2024-03-18 at 4 39 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cd19d032-6f44-4535-a707-e383b13c0a85"></br>
<img width="576" alt="Screenshot 2024-03-18 at 4 57 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/52285aad-6037-48a4-81e8-2d8593b42386"></br></br>



#### 추이적 예시
  
<img width="458" alt="Screenshot 2024-03-18 at 4 58 11 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c7356d76-17f0-41ea-8372-55fd7c09c308"></br></br>


<img width="400" alt="Screenshot 2024-03-18 at 5 05 53 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/059b61e6-cf70-42fb-ab62-4e6611d8dba3"><img width="400" alt="Screenshot 2024-03-18 at 5 06 04 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c24e2ec8-eb0a-4881-87ce-86af79eaedc0"></br></br>


 
## 관계의 종류
### 1. 역관계(inverse relation) : 
집합 A에서 집합 B로의 관계 R이 있을때, 관계를 구성하는 각 순서쌍의 원소 순서를 바꾸어 B에서 A로의 관계
  R<sup>-1</sup> = { (b,a) | (a,b) ∈ R }
  
  <img width="561" alt="Screenshot 2024-03-18 at 5 22 05 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6e28f9ab-c22e-4ea6-acf2-a62ff4844090"><img width="398" alt="Screenshot 2024-03-18 at 5 22 20 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/20718bfa-6663-4027-b542-8a179a454528"></br></br>

### 2. 합성관계(composition relation) : 집합 A에서 집합 B로의 관계 R이 있고, 집합 B에서 집합 C로의 관계 S가 있을때,
 S∙R = { (a,c)∈ A×C | a ∈ A, b ∈ B, c ∈ C, (a,b) ∈ R, (b,c) ∈ S }  [주의] R∙S로 표기하지 않음에 주의하라!
 
<img width="414" alt="Screenshot 2024-03-18 at 5 22 38 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1bfb1a83-48f6-44a9-ac4d-a6cde6b88901"></br>

<img width="619" alt="Screenshot 2024-03-18 at 8 24 32 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0be80f0c-a464-4df5-835e-81beaa8841e9">


<img width="373" alt="Screenshot 2024-03-18 at 5 23 16 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6054115f-6348-484e-8387-029337e361b9"></br></br>

<img width="500" alt="Screenshot 2024-03-18 at 5 23 37 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8342bd1f-98e9-4815-bf12-f882f2134d77"><img width="500" alt="Screenshot 2024-03-18 at 5 25 03 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f45c79bd-551c-4213-a17c-9fe533a7721c"></br></br>

### 3. 동치관계(equivalence relation) : 
집합 A에 대한 관계 R이 있을때, R이 반사적이고, 대칭적이고, 추이적이면 R은 동치관계
- 나머지 합동관계는 항상 동치관계이다 : 두 정수 a, b에 대해 양의 정수 d로 나머지 연산을 하였을때 같은 값이 나온다
          R = { (a,b) | a ≣ b(mod d) }

<img width="496" alt="Screenshot 2024-03-18 at 5 36 23 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/74275881-3ab1-49f8-9e0b-5c4dfc083771"></br>

<img width="521" alt="Screenshot 2024-03-18 at 5 36 36 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/834fd0e4-72c8-4dd1-b55d-493c260df3d6"></br></br>

<img width="432" alt="Screenshot 2024-03-18 at 5 37 53 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/caed9ba6-efe4-4f3b-b43b-90d45aca91b4"><img width="384" alt="Screenshot 2024-03-18 at 5 38 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cb4fd769-140e-4da4-a3fd-bfeae5795b61"></br></br>

  
#### 동치류(equivalence class) : 
집합 A에 대한 관계 R이 동치관계일때, A의 각 원소 a에 대하여 a의 동치류는 a와 R의 관계를 가지는 A의 원소들의 집합
          [a] = { x ∈ A | aRx },  [a] = { x ∈ A | (a,x) ∈ R }
  a의 동치류라고 부른다

<img width="456" alt="Screenshot 2024-03-18 at 7 28 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/fc50bbe3-9ef3-40c2-80f7-89e3cdb2bd09"></br></br>
  
<img width="658" alt="Screenshot 2024-03-18 at 7 27 29 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d6f71fa1-5339-4e19-83be-b05561eb3929"></br>

<img width="493" alt="Screenshot 2024-03-18 at 5 44 47 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/64e88138-8c24-40b9-b652-4eb236cc6452"></br></br>



---
# 함수
## 기본사항
1. 함수(function) :
- 집합 X와 Y가 주어졌을때, X에서 Y로의 함수 f : X → Y 는 X의 `모든 원소`가 각각 `Y의 하나의 원소와 대응되는 관계`
- 함수가 되기 위해서는 `정의역`의 모든 원소는 그에 해당하는 `상`을 반드시 가져야 하며, 반드시 `최대 하나의 상`만을 가져야 한다
- $\forall$ x $\in$ X, $\exists$! y $\in$ Y, (x,y) $\in$ f 를 만족하는 x에서 y로의 관계 [ f $\subset$ X x Y ]
  
  <img width="574" alt="Screenshot 2024-03-27 at 2 05 33 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6d0e69ec-a806-4193-8905-11686c08e7dc">

<img width="434" alt="Screenshot 2024-03-27 at 2 08 15 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b5e385bb-5f84-4716-8ae2-1f989b076094">

<img width="585" alt="Screenshot 2024-03-27 at 2 29 11 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/237cf222-bf61-4185-879a-8411964e7089">

- f의 정의역(domain) : X 
- f의 공역(codomain) : Y
- 함수 f에 의해 정의역의 원소 x가 공역의 원소 y와 대응 : xfy
- x의 상(image) : y
- y의 역상(inverse image) : x `소문자 x`
- f의 치역(range) :
  - f(X) - 치역 설명시에 `대문자 X`
  - 정의역 X의 원소 x에 대한 모든 상의 집합
  - f(X) = { y ∈ Y | ∀x ∈ X, y=f(x) }
  - 치역은 공역의 부분집합이다
- 상수함수 :
  - 정의역의 값에 관계없이 항상 동일한 값이 나오는 함수, (예) f(x) = 1
  - f : X -> Y,  ∀x ∈ X, f(x) = c(c는 상수)
  - X의 모든원소 x에 대해 Y의 c(상수값)에만 대응된다.
- 항등함수 :
  - 어떠한 값을 입력하든 그대로의 값이 나오는 함수 (예) f(x) = x
  - f : X -> Y,  ∀x ∈ X, f(x) = x
  - Ix (Identity x)
  - X의 모든 원소에 대해서 같은 X로 대응된다.
- 제곱함수 : f(x) = x<sup>2</sup>
- 함수의 상등(equal function) :
  - 정의역과 공역이 같고, 정의역의 모든 원소 x에 대하여 f(x) = g(x)의 값이 같을때, 두 함수 f와 g는 서로 ‘상등하다’, `f = g`
  - f : X -> Y, g : A -> B 가 함수일 때
  - `X = A` (f,g 함수의 정의역끼리 같고), ` Y = B` (f,g 함수의 공역끼리 같다) 
  - ∀x ∈ X, f(x) = g(x)
  - f와 g는 '상등하다' [서로 같다]
    
<img width="439" alt="Screenshot 2024-03-27 at 2 50 19 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ec2c84dc-875c-460a-99f0-1936682daa26">

 예시 $\sqrt x$ <sup>2</sup>  = |x|
 
<img width="645" alt="Screenshot 2024-03-27 at 2 55 42 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d945e370-4923-4fc7-8bd6-ab2b11ae2070">

## 전사, 단사, 역함수
1) 전사함수(surjection function, onto function) : 공역 Y의 모든 원소에 대해, f(x) = y가 되는 x가 적어도 하나 존재할 경우
          ∀y ∈ Y, ∃x ∈ X, f(x) = y
   
<img width="393" alt="Screenshot 2024-03-27 at 2 59 38 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/409f190a-794f-4afe-b8fa-97803f6f97d5">

3) 단사함수(injection function, one-to-one function) : 임의의 치역의 원소 y에 대응하는 정의역의 원소가 하나뿐일 경우
          ∀a,∀b∈X, f(a) = f(b)일 경우 a = b
   
<img width="468" alt="Screenshot 2024-03-27 at 3 05 48 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/684bb8da-8f12-4e30-9cbf-1a180e628612">

5) 전단사함수(bijection function, one-to-one correspondence function) :
   - 전사함수이면서 단사함수일 경우
   - ∀y ∈ Y, ∃x ∈ X, f(x) = y 이고 ∀a,∀b ∈ X, f(a) = f(b)일 경우 a = b 이다
   - X의 각 원소가 단 하나의 Y의 원소와 관계를 가지며, Y의 각 원소가 단 하나의 X의 원소와 관계를 가진다.
   - 역함수 존재하고, 역함수도 전단사 함수임
   - 정의역과 공역 원소의 갯수가 같아야 함
     
 <img width="472" alt="Screenshot 2024-03-27 at 3 12 43 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c00753fb-40fe-4f67-9f96-aae5d67333ed">

6) 역함수 f<sup>-1</sup> : 함수 f : X → Y가 전단사함수일때,  Y의 원소 y에 대해, 함수 f<sup>-1</sup> : Y → X
          ∀x ∈ X, ∀y ∈ Y, f(x) = y

<img width="431" alt="Screenshot 2024-03-27 at 3 15 04 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/410add7d-72cb-47b6-bdaa-60911845d6f6">

<img width="626" alt="Screenshot 2024-03-27 at 3 17 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/11541f7a-79a9-45ff-a63a-1c122c750d7d">


7) 합성함수 : 
- X ,Y’, Y , Z : 집합  Y’$\subset$ Y (Y프라임 `Y’`은 Y라는 집합의 부분집합)
- 두 함수 f : X → Y’ 와  g : Y → Z 에 대해
- 다음과 같이 정의되는 함수  g∘f : X → Z 를 f와 g의 합성합수라고 한다.
          ∀x ∈ X, (g∘f)(x) = g(f(x))
  
   - f의 치역은 g의 정의역에 포함되어야 한다
   - f: X -> Y, g: Y -> Z 에 대해
   - 전사함수끼리의 합성함수는 전사함수이다. g∘f : X → Z 도 전사함수
   - 단사함수끼리의 합성함수는 단사함수이다. g∘f : X → Z 도 단사함수
     
<img width="214" alt="Screenshot 2024-03-27 at 3 39 52 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/49373367-e41d-4d2b-b3bd-4e2fff4fd805">

<img width="560" alt="Screenshot 2024-03-27 at 3 51 43 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/9dedd8f7-7c5d-4c7d-8602-fd4623d3a9ad">

<img width="566" alt="Screenshot 2024-03-27 at 3 53 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8c25da05-08f6-40dc-a442-448cecd815ff">


## 함수의 종류
1) 계승함수(factorial) : 음이 아닌 정수 n에 대해서 계승함수 n!은 다음과 같이 정의된다

   <img width="505" alt="Screenshot 2024-03-27 at 3 55 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8221cb4e-4171-45dd-adad-a5ed3205af39">

2) 바닥함수(floor) : 실수 x에 대해, x보다 작거나 같으면서 가장 큰 정수를 구하는 함수, ⌊ x ⌋, floor(x)

   <img width="455" alt="Screenshot 2024-03-27 at 3 59 50 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/9f7bd548-5922-40ea-9cba-3abd25736a12">
   
   <img width="447" alt="Screenshot 2024-03-27 at 4 00 52 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/53d689aa-e35d-4ad0-b135-ce0bfed31805">


3) 천장함수(ceiling) : 실수 x에 대해, x보다 크거나 같으면서 가장 작은 정수를 구하는 함수, ⌈ x ⌉, ceiling(x)

<img width="435" alt="Screenshot 2024-03-27 at 4 01 26 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/426be121-0457-4dcf-9b69-933c6f089677">

<img width="397" alt="Screenshot 2024-03-27 at 4 01 47 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1800e5f6-77db-4fbe-9058-3384b59d32d6">

<img width="419" alt="Screenshot 2024-03-27 at 4 02 10 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/60cb4ef6-f94d-44de-b3f3-4e6d45396907">

        
4) 나머지함수(modular): %

<img width="566" alt="Screenshot 2024-03-27 at 4 03 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/87c951da-f9f9-4e1a-9a99-b8e817c31a09">

<img width="412" alt="Screenshot 2024-03-27 at 4 04 24 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/96328afc-bd9e-44bb-8afe-4b40f2c868a8">




---
# 부울대수

## 기본사항
### 디지털 논리회로

<img width="632" alt="Screenshot 2024-04-24 at 1 15 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cf4ae22f-367c-4d9a-9206-74c1feffee67">

### 논리게이트

<img width="500" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/1531cdd6-19b6-43c8-a76c-4c3c20640abf">


## 부울대수

<img width="578" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/373fef48-a0a1-4775-8a70-7d8f21cf4fe5">

<img width="578" alt="Screenshot 2024-04-24 at 1 21 43 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/fafd15ae-b28d-4a96-b3ae-6e4e2c4fc2d3">

<img width="577" alt="Screenshot 2024-04-24 at 1 22 19 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e60dc7db-e640-4a1d-8c1d-0a1d6210b078">

  
### 쌍대성 원리(principle of duality) : 부울대수식에서 논리연산자인 +와 ∙ , 그리고 논리값 1과 0을 맞바꾸면 쌍대 형태(dual form)을 얻게 되는 원리
주어진 부울식과 그것은 쌍대는 진리값이 서로 같다.

#### 부울함수의 보수 :
 ➀ F의 값을 0은 1로, 1은 0으로 바꿈으로써 얻을 수 있다
 ➁ 대수적으로 드모르간 법칙을 이용하여 얻을 수 있다
 ➂ 논리연산자 AND(+)와 OR( ∙ )를 바꾸어 쌍대를 취한후, 각 문자에 보수를 취하여 얻을 수 있다
 
<img width="473" alt="Screenshot 2024-04-24 at 1 33 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8b0bca29-122a-4eb1-850b-b15d93f69872">

<img width="468" alt="Screenshot 2024-04-24 at 1 34 20 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/156e2492-28e1-42f0-afe1-dcb022a4d10b">


## 부울함수의 대수적 간소화

<img width="563" alt="Screenshot 2024-04-24 at 2 41 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1feb8635-0a56-4e2f-a436-fdf639d4e684">

- 부울함수에서 문자(literal)는 정상형 또는 보수형으로 나타난 논리변수 (게이트 입력)
- 항(term)은 문자들이 논리연산자에 의해 서로 연결된 것 (게이트)
 1) 항 결합 : 두 개의 항을 결합하여 하나의 항으로 만드는 것
 2) 문자소거 : 중복된 문자들을 제거
 3) 중복항 첨가
 4) 합의 정리(consensus theorem) :
- 콘센서스항(consensus term) : 어느 한 변수가 어느 한 항에 있고, 그 변수의 보수가 다른 항에 있을때,
  나머지 변수의 곱으로 이루어진 항은 필요없게 된다.

<img width="579" alt="Screenshot 2024-04-24 at 2 44 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e486c495-9b59-4cdb-83b5-5ff2193e9477">

---
# 그래프-1

## 1. 기본사항
### 1) 그래프 : 정점(vertex)들의 유한집합 V 와 정점들의 쌍을 연결하는 간선(edge)들의 유한집합 E 로 구성, G=(V,E)
- 꼭지점(vertex) : 점 node,station
- 변(edge) : 두 꼭지점을 연결하는 선 link, line
- 인접(adjacednt)한다 : 연결된 두 꼭지점
- 루프(loop) : 동일한 꼭지점을 연결하는 변
- 병렬(parallel) 변 : 두 꼭지점을 연결하는 변이 두 개 이상 있을때
- 고립(isolated) : 어떠한 변도 연결되지 않은 꼭지점
- 동형(isomorphic) : 꼭지점과 변의 이름을 제외하고 모두 동일한 그래프 (이름만 다르지 형이 같음)

### 2) 방향 그래프
- 무향 그래프(undirected graph) : 그래프의 변이 방향을 가지고 있지 않다 (꼭지점들 사이에 전후관계가 없다)
- 방향 그래프(directed graph) : 그래프의 변이 방향을 가지고 있다 (자료구조)
           
### 3) 단순 그래프(simple graph) : `루프`나 `병렬 변`을 _가지지 않는_ `무향` 그래프
### 4) 부분 그래프(subgraph) : 하나의 그래프는 다른 그래프에 포함될 수 있다. 포함되는 그래프
### 5) 신장 부분 그래프(spanning subgraph) : 꼭지점이 완전히 일치하는 부분 그래프 일 때 변의 갯수가 줄어듦

### 6) 차수(degree) :
- 그래프 G의 꼭지점 v에 대해 v에 인접한 변의 개수
- 변이 루프일 경우 +2
- G의 총 차수 : 그래프 G에 있는 모든 꼭지점 차수의 합 (항상 변의 개수의 두 배, __짝수__ 가 된다)
- 방향그래프에서 해당 꼭지점으로 들어오는 __진입차수__, 나가는 __진출차수__
- 그래프의 `차수가 홀수` => `꼭지점 수는 짝수`

### 7) 워크 > 트레일 > 경로 > 사이클  What The PC
그래프 G=(V,E)에 꼭지점 v<sub>0</sub>과 v<sub>k</sub>가 있을때,
- __워크(walk)__ : v<sub>0</sub>에서 v<sub>k</sub>까지의 워크는 W=v<sub>0</sub>e<sub>1</sub>v<sub>1</sub>e<sub>2</sub>v<sub>2</sub>⋯ e<sub>k</sub>v<sub>k</sub>의 형태를 가지는 유한한 순서쌍이다
- __시작점(origin)__ : v<sub>0</sub>
- __종점(terminus)__ : v<sub>k</sub>
- __내부점(internal vertices)__ : v<sub>1</sub>, v<sub>2</sub>, ⋯ v<sub>k-1</sub> 시작점, 종점 사이의 꼭지점들
- __W의 길이(length)__ : 정수 k
- __닫혀있다(closed)__ : 시작점과 종점이 같을 경우 v<sub>0</sub> = v<sub>k</sub>
- __트레일(trail)__ : 워크 W의 __변들__ e<sub>1</sub>, e2 e<sub>2</sub>, ⋯  e<sub>k</sub>가 모두 서로 다를 경우
- __경로(path)__ : 트레일 W의 __꼭지점들__ v<sub>0</sub>, v<sub>1</sub>, ⋯ v<sub>k</sub>가 모두 서로 다를 경우
  
### 8) 닫힌 트레일과 사이클
- 닫힌 트레일(closed trail) : 워크의 변들이 모두 서로 다르면서 v<sub>0</sub> 와 v<sub>k</sub>가 동일한 경우
- 사이클(cycle) : 닫힌 경로 중에서 v<sub>0</sub>, v<sub>1</sub>, ⋯  v<sub>k-1</sub>까지의 꼭지점이 모두 서로 다를 경우 (시작 꼭지점과 끝 꼭지점이 동일한 경로)

### 9) 연결성분과 연결그래프
- __연결되어 있다__ : 두 꼭지점 u, v를 서로 연결하는 경로가 있을 경우
- __연결성분__ : 서로 연결되고 다른 집합과 겹치지 않는 꼭지점의 집합의 원소 각각
- __연결그래프__ : 그래프 안에 있는 모든 꼭지점 간에 경로가 존재. __오직 하나의__ 연결 성분(연결요소)만 있을 경우- 분리되지 않았다는 말 (두 꼭지점 집합으로 분리되는 그래프는 연결그래프 아님)

<img width="447" alt="Screenshot 2024-04-24 at 4 45 42 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e591ee59-22d3-44e5-ac80-c1e26e4fa45b">

(1) 연결그래프이다. (2) 연결그래프가 아니다. (a,b,c,d 와 e,f간의 경로가 존재하지 않는다.)

<img width="653" alt="Screenshot 2024-04-25 at 7 59 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/10b59b33-bacc-4507-8d31-2f4119921e6e">

## 2. 그래프의 종류
### 1) 완전 그래프(complete graph) :
- 그래프 G=(V,E)의 __모든 꼭지점이 다른 꼭지점과 인접할 경우__
- n개의 꼭지점을 가지는 완전그래프를 K<sub>n</sub>
- 임의의 두 꼭지점을 연결하는 변이 항상 존재하는 그래프


<img width="535" alt="Screenshot 2024-04-24 at 4 35 12 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4c5dbf72-4cbb-4395-b72a-ab577d5cdd54">

<img width="469" alt="Screenshot 2024-04-24 at 4 50 20 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6bab4cfa-2bc8-4fc1-a064-abeda3889690">

(1) 완전그래프가 아니다. (육각형 가운데 꼭지점이 위치함으로써, 모든 꼭지점 간에 변이 존재하지 않는 것이 있다.) (2) 완전 그래프이다.
           
### 2) 이분 그래프(bipartite graph) :
- 그래프 G=(V,E)의 V가 연결성분 V<sub>1</sub>과 V<sub>2</sub>로 분할되어 있고, 모든 변들이 V<sub>1</sub>꼭지점과 V<sub>2</sub> 꼭지점을 연결할 경우
- 단순 그래프 G에서 꼭지점들의 집합 V가 겹치지 않는 두개의 집합 V<sub>1</sub>과 V<sub>2</sub>로 분리되고, 모든 변은 V<sub>1</sub>의 한 꼭지점과 V<sub>2</sub>의 한 꼭지점에만 연결한다면, 이 단순 그래프를 이분 그래프라고 한다. 그래프 G 에서 V<sub>1</sub>과 V<sub>2</sub> 두 꼭지점 사이를 연결하는 변은 존재하지 않는다. 이 조건을 만족하면 G의 꼭지점 집합 V의 이분(bipartition)이라고 한다.
- 그래프 채색을 이용한 이분 그래프 판별: 이분 그래프일 때 필요충분조건은 두 인접한 꼭지점들이 같은 색깔을 갖지 않도록 두 개의 색으로 그래프의 모든 꼭지점들을 칠할 수 있어야 한다.
  
- ~~그래프의 꼭지점을 두 가지 색으로 칠할때, 모든 변의 양 꼭지점이 서로 다른 색으로 칠해질 수 있는 그래프~~
- ~~그래프 내부에 홀수의 길이를 가지는 사이클을 가지지 않는다~~

<img width="462" alt="Screenshot 2024-04-25 at 8 04 20 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b5f76b77-dcbc-4a67-9943-bbfacc71105e">




[참고](https://00ad-8e71-00ff-055d.tistory.com/114)

### 3) 완전 이분 그래프

- G = (V,E) : 이분 그래프 (V<sub>1</sub> ⊕ V<sub>2</sub> = V)
- 완전 이분 그래프 K<sub>m,n</sub>은 꼭지점의 집합이 각각 m 과 n 개의 꼭지점들을 갖는 두 부분집합으로 나누어지는 그래프이다. 한 꼭지점은 첫 번째 부분집합에 속하고, 다른 꼭지점은 두 번째 부분집합에 속할 때만 두 꼭지점 간에 변이 존재한다. 
- 어떤 꼭지점 꺼내도 연결하는 변이 있어야 함

<img width="578" alt="Screenshot 2024-04-25 at 8 05 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ffb5c654-3021-4421-a38b-576e4f61002a">

### 4) 정규 그래프(regular graph) :
- 그래프 G=(V,E)의 모든 꼭지점들이 동일한 수(차수)의 이웃을 가질 경우
- 모든 꼭지점들은 동일한 차수를 가진다. k-정규 그래프

<img width="509" alt="Screenshot 2024-04-25 at 8 06 45 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/3d31c7c9-2054-40af-b4ab-4510be73570f">


## 3. 그래프의 표현

### 1) 발생행렬(incidence matrix) :
- 그래프의 꼭지점을 행렬의 행으로, 변을 열로 하여, 꼭지점과 변의 연결(발생)관계를 표현한 것 => 발생행렬 M<sub>1</sub> = (a<sub>ij</sub>)
- 인접관계가 있을 경우 1로, 인접관계가 아닐 경우 0의 원소
- |V| x |E| 크기의 부울행렬
- a<sub>ij</sub> = 1 (V<sub>i</sub> 가 e<sub>j</sub>에 의해 발생되는 경우)
- a<sub>ij</sub> = 0 (그 밖의 경우)
  
<img width="469" alt="Screenshot 2024-04-24 at 3 56 43 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/18e9b1d6-19f1-4b6c-a3de-afc485d7cf4c">

<img width="415" alt="Screenshot 2024-04-24 at 4 08 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/26701e5a-80e9-476c-84cc-62e6f6dc6251">


### 2) 인접행렬(adjacency matrix) : "인접 행렬"
- 그래프의 꼭지점을 행렬의 행과 열로 하여, 꼭지점과 꼭지점 사이의 연결(인접)관계를 표현한 것 => 
- 꼭지점 v<sub>i</sub>에서 v<sub>j</sub> 로의 연결개수가 행렬의 ( i, j )의 원소의 값이 되며, 무향그래프일 경우 항상 대칭행렬이다
- |V| x |V| 크기의 행렬
- a<sub>ij</sub> =  v<sub>i</sub> 에서 v<sub>j</sub> 로의 연결 개수

<img width="369" alt="Screenshot 2024-04-24 at 4 09 22 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1c99eb51-f042-4f3b-a4f7-04ac033ef87b">
<img width="368" alt="Screenshot 2024-04-24 at 4 09 33 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cdfe4eef-232d-4128-ac68-5f84f6cd206a">

<img width="390" alt="Screenshot 2024-04-24 at 4 24 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/09b6ff7a-24ff-4d3a-9442-0f66c929f457">

          
### 3) 인접리스트(adjacency list) :
- 각 꼭지점에 인접하는 꼭지접들을 차례로 연결 리스트로 표현한 것

# 그래프-2

### 4. 그래프 탐색

#### 1) 평면 그래프(planar graph) :
- 그래프의 모든 변을 서로 교차하지 않게 그릴 수 있는 그래프 (교차선이 없어 평면을 확보할 수 있다)
- 4색 정리 : 평면그래프가 주어졌을때, 각 꼭지점에 대하여 인접한 꼭지점과 다른 색으로 칠하는데 필요한 색은 4가지면 충분하다

"`오일` 넣어 `트레일` 따라 `투어` 가자, `해밀턴`은 우리 `경로` 로 `사이클` 타고 온대"
#### 2) 오일러 트레일(Euler trail) :
- 그래프의 __모든 변__ 들을 각각 정확히 __한 번__ 만 지나는 트레일
- 홀수 2개와 나머지 짝수의 꼭지점을 가진다, 시작점과 종점이 다르다

#### 3) 오일러 투어(Euler tours)/순환,회로 :
- 모든 변을 __적어도 한 번씩__ 지나가는 __닫힌__ 워크로, __시작점과 종점이 동일__ 한 오일러 트레일
- 오일러 투어를 가지기 위한 필요충분조건은 __모든 꼭지점의 차수는 짝수__ 이다

#### 4) 해밀턴 경로(Hamilton path) :
- 그래프의 __모든 꼭지점__ 을 각각 정확히 __한 번__ 만 지나는 경로

#### 5) 해밀턴 사이클(Hamilton cycle) :
- __시작점과 종점이 동일__ 한 해밀턴 경로
  
<img width="429" alt="Screenshot 2024-04-24 at 8 42 55 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8c355f73-4bb0-4b4e-876e-5b3ea2143c83">


### 5. 그래프 활용
#### 1) 가중 그래프
- 그래프의 각 변에 실수값이 붙여진 그래프
- 변에 부여된 값은 가중치 라고 함.

#### 최단경로 문제
- 어떠한 변도 음수값을 갖지 않은 방향 그래프에서 주어진 __출발점과 도착점 사이의 최단경로__ 를 찾아주는 알고리즘을 찾는 문제
- 최단경로를 구할 때는 출발점부터 도착점까지 경로에 포함되는 꼭지점들을 나열하고, 각 변 혹은 화살표에 부여된 가중치를 더하여, 가장 적은 가중치 합을 갖는 경로를 선택. 이때 __다익스트라 알고리즘__ 사용할 수 있음.

#### 다익스트라(Dijkstra) 알고리즘 : 
한 정점(노드)에서 다른 정점까지의 최단경로 구하는 알고리즘 중 하나이다. 이 과정에서 도착 정점 뿐 아니라 모든 다른 정점까지 최단 경로로 방문하며, 각 정점까지의 최단 경로를 모두 찾게 된다. 매번 최단 경로의 정점을 선택해 탐색을 반복한다.

동작단계 :
1. 출발 노드와 도착 노드를 설정
2. '최단 거리 테이블'을 초기화
3. 현재 위치한 노드의 인접 노드 중 방문하지 않은 노드를 구별하고, 방문하지 않은 노드 중 거리가 가장 짧은 노드 선택하고 방문하여 처리
4. 해당 노드를 거쳐 다른 노드로 넘어가는 간선비용(가중치)을 계산해 '최단 거리 테이블'을 업데이트 한다.
5. 3~4의 과정을 반복한다.

'최단 거리 테이블' 은 1차원 배열로, n개 노드까지 오는데 필요한 최단거리를 기록한다. n개 (1부터 시작하는 노드 번호와 일치시키려면 n+1개 ) 크기의 배열을 선언하고 큰 값을 넣어 초기화 시킨다.

'노드 방문 여부 체크 배열'은 방문한 노드인지 아닌지 기록하기 위한 배열로, 크기는 '최단 거리 테이블'과 같다. 기본적으로는 `false`로 초기화하여 방문하지 않았음을 명시한다.

동작 예시 :

<img width="554" alt="Screenshot 2024-04-24 at 9 56 46 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/265a7659-ca74-40f4-8761-0fc51cdaea63">

- 출발노드는 1번, 도착노드는 6번
- 거리 테이블을 전부 큰 값, 여기서는 inf(무한대)로 초기화 함.
- 각 노드들 잇는 간선의 가중치 역시 표시

<img width="546" alt="Screenshot 2024-04-24 at 10 03 11 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/43824075-4864-4fec-a821-437f95b44b8b">

- 출발 노드 선택하고, 거리를 0으로 함

<img width="530" alt="Screenshot 2024-04-24 at 10 03 59 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e060f6cb-7aff-45e9-a144-a5563e96e019">

- 1번 노드와 연결된 인접 노드는 2, 4
- 두 인접 노드로 가는 거리를 무한대(inf) 초기값과 비교해 최소값으로 둘 다 업데이트, min() 함수사용
- 인접 노드까지 거리를 모두 업데이트한 1번 노드는 방문표시함
- 최근 갱신한 테이블 기준(2,4)으로, 방문하지 않은 노드 중 가장 거리값이 작은 번호를 다음 노드로 택함, 위 상태에서는 4번 노드

<img width="529" alt="Screenshot 2024-04-24 at 10 08 30 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/40eeff0f-d587-4885-8b37-cc79b7804128">

- 4번 노드에서 같은 작업 수행, 시작노드에서 4번과 인접한 2,5 번 노드까지의 거리를 계산
- 5번노드 = 4번까지 가중치(1) + 4~5 간선의 가중치(1) = 2 와 기존 값 inf 중 최소값 계산
- 2번노드 = 4번까지 가중치(1) + 4~2 간선의 가중치(2) = 3 와 기존 값(업데이트된) 2 중 최소값 계산
- 5번 노드는 2로 업데이트, 2번 노드는 기존 값 2보다 더 큰 3 이므로 최소값 만족하지 않으므로 업데이트 하지 않음. (_1번에서 바로 2번으로 가는 것이 4번을 거쳐 2번으로 가는 것보다 적게 걸린다는 뜻_)
- 업데이트된 2,5 의 거리값이 2로 같은데, 거리 값이 같다면 인덱스가 작은 노드를 선택한다 가정하고 2번 선택한다.
- ~~4번 노드 방문표시~~ 

<img width="536" alt="Screenshot 2024-04-24 at 10 42 14 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c16b47a1-1620-4036-8af2-8aa2111cc08f">

- 2번 노드와 연결된 3,4 번 노드에 대해 같은 과정 반복 (~~4번은 지나왔는데 왜 또함??~~)
- 2번까지 오는 최단거리는 1번에서 2번으로 바로오는 거리인 2
- 3번 노드 = 2 + 3 = 5,  min(inf,5) = 5 , 5 업데이트
- 4번 노드 = 2 + 2 = 4,  min (1, 4) = 1 , 기존값 1 유지
- 작은 거리값인 4번 노드 선택?
- 5번 노드 선택

<img width="530" alt="Screenshot 2024-04-24 at 10 57 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0e922bc1-3487-460d-a8b3-a4395364dd5c">

- 5번 노드와 연결된 6번 노드에 같은 과정 반복
- 아직 방문하지 않은 3,6번 중 거리값이 작은 6번
- 도착노트 이므로 알고리즘 종료

<img width="545" alt="Screenshot 2024-04-24 at 10 59 14 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c5a6c1e0-12fa-42fa-b5a2-261226f94e0f">

- 최종적으로 1번에서 6번까지 오는데 1-4-5-6 경로를 거치고 최소거리는 4가 된다.
- 다익스트라 알고리즘은 방문하지 않은 노드 중 최단거리인 노드를 선택하는 과정을 반복한다.
- 또한 각 단계마다 탐색노드로 한 번 선택된 노드는 최단거리를 갱신하고, 그 뒤에는 더 작은 값으로 다시 갱신되지 않는다.
- 도착노드는 해당 노드를 거쳐 다른 노드로 가는 길을 찾을 필요는 없다.
- 가중치가 양수일 때만 사용 가능하다.



[참고](https://velog.io/@717lumos/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
  
#### 최소 신장 트리 문제
- __그래프의 모든 꼭지점을 최소 수의 변으로 연결__ 하는 문제
- 트리 : 사이클이 없는 연결 그래프
- 신장 트리(Spanning Tree) : 
  - 연결 그래프의 부분그래프
  - 정점 간 서로 연결되어 있어야 함
  - 사이클이 존재하지 않는 그래프
  - 연결 그래프에서 신장트리는 1개가 아닌 다수 일 수 있음
  - 그래프 G = (V,E)의 모든 꼭지점을 연결하고, 사이클이 없는 G의 부분 그래프를 G의 신장트리
    
- 최소 신장트리(MST-Minimum Cost Spanning Tree) : 
  - 트리를 구성하는 간선들의 가중치를 합한 값이 최소가 되는 신장트리
  - 가중치 무방향 그래프가 베이스일 때 구할 수 있음
  - MST 를 찾아내는 방법은 다양하며 대표적으로 (크루스칼, 프림) 알고리즘이 있음
  - 가중치 그래프 G의 신장트리 중 총 가중치가 가장 작은 신장 트리
  - 사용사례 : 도로건설(도로모두연결하고 도로길이최소), 전기회로(단자모두연결하고 전선길이최소), 통신(전화선길이최소), 배관(파이프모두연결하고 파이프총길이최소)

---

# 트리

<img width="356" alt="Screenshot 2024-04-25 at 2 15 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/87306405-ce73-460e-84a3-7dc2814316c4">

n개의 꼭지점을 가지는 연결그래프가 n-1개의 변을 가지면 해당 그래프는 트리

## 1. 기본사항
### 1) 트리(tree) : 사이클이 없는 연결 그래프 (부모와 자식들 사이의 관계를 표현하기위한 자료구조)
   - 노드(node) : 꼭지점, 각 노드는 자식 노드의 개수만을 차수로 가진다
   - 사소한 트리(trivial tree) : 하나의 꼭지점으로 구성된 트리
   - 공백 트리(empty tree) : 어떠한 꼭지점도 없는 트리
   - 포레스트(forest) : 한 개 이상의 트리로 구성된 그래프
   - n개의 꼭지점을 가지는 트리는 n-1개의 변을 가진다

### 2) 루트 트리(rooted tree) :
   - 루트(root)라 부르는 특정한 노드가 1개 존재한다
   - 나머지 노드들은 m개의 서로 분리된 집합(서브트리, subtree)으로 나뉘며 다시 루트 트리가 된다
   - 진입차수는 0
   - 레벨은 0

### 3) 트리 구조
   트리의 노드 N이 서브트리를 갖는다면,
   - 자식노드(child node) : 각 서브트리
   - 부모노드(parent node) : 이때 노드 N, 모든 자식노드는 언제나 하나의 부모노드만 갖는다
   - 형제노드(sibling node) : 같은 부모를 갖는 노드
   - 리프(leaf)/단말노드(terminal node) : 차수가 0인 노드
   - 내부노드(internal node) : 루트도 아니고 리프도 아닌 트리 내의 노드
   - 트리의 차수(degree) : 한 트리내의 각 노드 차수 가운데 최대 차수
   - 레벨(level) : 루트로부터 그 노드까지의 경로길이
   - 높이(height)/깊이(depth) : 노드들의 레벨 중 가장 큰 레벨
   - 무게(weight) : 리프 노드들의 개수
          
 <img width="449" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/1bd2cece-083a-4e62-b9d7-8d4a521dc3cb">
           
### 4) 트리 종류 :
이진트리, m-원 트리, 힙, 이진탐색트리, AVL트리, BB트리, 스플레이트리, 트라이,m-원 탐색트리, B*트리, B+트리, 2-3트리, 2-3-4트리, 레드블랙트리

<img width="469" alt="Screenshot 2024-04-25 at 2 13 52 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/2f508359-3ddf-4867-b41a-0b83ae5d32bb">


## 2. 이진트리

### 1) 이진트리(binary tree) :
- 공집합이거나 모든 노드가 최대 2개의 서브트리를 가지는 루트 트리
- 왼쪽 서브트리(left subtree)와 오른쪽 서브트리(right subtree) 각각 한 개씩만을 가진다
- 왼쪽 혹은 오른쪽이 아닌 아래쪽으로 향하고 있는 트리는 이진트리가 아니다

<img width="271" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/c307b8f6-15f9-4923-b5ad-df9cc0b72ba5"></br>

<img width="291" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/d58a104e-336f-40c7-b63e-9232a2c8e557">

- log : 어떤 수를 나타내기 위해 고정된 밑을 몇 번 곱하여야 하는지를 나타내는 함수
- 2<sup>x</sup>=n 이므로 log<sub>2</sub>n = x   (예) 16개의 노드를 가지는 이진트리의 최소높이는? 2<sup>x</sup>=16 이므로 log<sup>2</sup>16 = log<sub>2</sub>2<sup>4</sup> = 4

### 2) 포화 이진트리(full binary tree) : 빈 자리 없이 노드를 모두 가진 이진트리

### 3) 완전 이진트리(complete binary tree) :
- 높이가 h인 트리에서 레벨0부터 h-1까지 모든 노드가 채워져 있고, 레벨 h에서는 왼쪽 노드부터 차례로 채워진 이진트리
- 완전 이진트리는 같은 노드 수를 갖는 트리 중 최소의 높이를 갖는다.
- n개의 노드를 갖는 포화/완전 이진트리의 최소높이 H<sub>min</sub> = | log<sub>2</sub>n | + 1
  
### 4) 경사 이진트리(skewed binary tree) : 한쪽으로만 뻗어나간 이진트리
- 4개의 노드를 가지는 경사 이진트리의 최대높이는 3이다

## 3. 이진 탐색 트리(binary search tree) :
- 각 노드가 유일한 키값을 가지며, 각 노드의 왼쪽 서브트리의 모든 키값은 해당노드의 키값보다 작고, 오른쪽 서브트리의 모든 키값은 해당노드의 키값보다 크다
- 루트 노드로 부터 키값 비교를 통해 작으면 왼쪽가지, 크면 오른쪽가지를 따라 탐색
- 비교횟수

### 이진 탐색트리 검색
1. 탐색 노드를 루트노드로 설정
2. 탐색 노드를 주어진 키와 비교해 
 - 일치하면 키 반환하고 탐색 정지
 - 주어진 키가 현재 탐색노드보다 작다면 왼쪽 자식을 탐색노드로 설정, 왼쪽자식 없을 경우 키 없음 반환하고 탐색정지
 - 주어진 키가 현재 탐색노드보다 크다면 오른쪽 자식을 탐색노드로 설정, 오른쪽 자식 없을 경우, 키없음 반환하고 탐색정지
3. 2번 과정을 반복

## 4. 트리의 활용
1) 신장 트리(spanning tree, 걸쳐있다?) : 모든 꼭지점을 연결하고 사이클이 존재하지 않는 부분그래프
### 2) 최소 신장 트리(minimum spanning tree) : 가중치 무방향 그래프에서 가중치의 합(total weight)이 가장 작은 신장 트리
#### a.크루스칼(Kruskal) 알고리즘 :
- 가중치의 오름차순으로 변을 정렬한다.
- 가장 작은 가중치의 변부터 차례대로 트리에 추가한다 (단, 사이클이 되지 않아야 한다)
- 모든 꼭지점이 연결될 때까지 2번과정 반복

#### b. 프림(Prim) 알고리즘 :
- 임의의 꼭지점 하나를 트리에 추가
- 트리의 꼭지점이 아니면서 트리와 연결된 꼭지점 중에서 가장 작은 가중치의 변으로 연결된 꼭지점을 추가한다.
- 모든 꼭지점이 연결될 때까지 2번 과정 반복



---
# 조합이론
# 정수론
# 오토마타-및-형식언어
# 종합정리

