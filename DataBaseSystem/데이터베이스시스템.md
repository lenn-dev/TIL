<img width="563" alt="Screenshot 2024-04-10 at 10 17 49 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/09159cb4-257f-4b3f-9671-6ac7fd1c06bf"><강의>
출석수업 
1	데이터베이스의 이해	- 데이터베이스 관련 용어 소개 - 데이터베이스 관리 시스템의 목적, 특징 구조	2-21
3	데이터베이스 모델링	- 데이터베이스 모델링 과정 - 데이터 모델 - ER 모델(개체 집합과 관계 집합) - ER 모델(ER 모델 제약조건, 약한관계, 재귀작 관계 등)	34-55	
5	관계형 모델 (1)	- 관계형 모델 - ER 모델 변환 - 관계대수	64-88
### 목차
1. [데이터베이스의 이해](#데이터베이스의-이해)
2. [데이터베이스 모델링](#데이터베이스-모델링)
3. [관계형 모델](#관계형-모델)
4. [SQL 1](#sql-1)
5. [SQL 2](#sql-2)
6. [SQL 3](#sql-3)
7. [정규화](#정규화)
8. [연습문제 풀이 1](#연습문제-풀이-1)
9. [데이터 저장과 파일](#데이터-저장과-파일)
10. [인덱싱](#인덱싱)
11. [해싱과 특수 인덱스](#해싱과-특수-인덱스)
12. [트랜잭션](#트랜잭션)
13. [동시성 제어](#동시성-제어)
14. [회복 시스템](#회복-시스템)
15. [연습문제 풀이 2](#연습문제-풀이-2)

# 데이터베이스의 이해
#### 학습목표
- 데이터베이스의 역할을 이해할 수 있다.
- 데이터베이스의 특징을 이해할 수 있다.
- 데이터베이스의 구성요소를 파악할 수 있다.

데이터단위 bit * 8 byte * 1024 kilobyte(KB) * 1024 megabyte(MB) * 1024 gigabyte(GB) * 1024 terabyte(TB) * 1024 petabyte(PB) * 1024 exabyte(EB) * 1024 zettabyte(ZB) * 1024 yottabyte(YB)

### 1. 데이터베이스의 역할
  #### 1. 데이터 관리의 필요
  데이터 =저장=> 데이터관리장치 =검색=> 필요데이터
  #### 2. 데이터 관리의 역사
<img width="534" alt="Screenshot 2024-02-21 at 12 18 54 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/dfb12bcc-2afd-45d8-b817-adb14c616e14">

  #### 3. 파일 처리 시스템 (file processing system):전통 데이터 관리 방식
  <img width="449" alt="Screenshot 2024-02-21 at 12 19 52 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f73d6482-dd04-4210-86c5-89a72cb3f203">

- 업무별 애플리케이션이 __개별데이터__ 를 데이터 파일에 저장,관리하는 시스템 
- 발생가능문제 </br>
  * __데이터 종속 문제__ : </br>
    - 물리적 데이터 종속: 저장된 데이터가 특정 H/W(신규디스크) 상태가 변경되었을 때 곧바로 S/W(애플리케이션) 수정,보완이 어려워서 사용자의 접근이 제한됨 </br> (e.g> 디스크부족시, 신규디스크를 추가해서 사용자의 정보를 저장했을때 사용자는 신규디스크에 직접 접근할 수 없음</br>
    - 논리적 데이터 종속: 효율적 데이터 저장위해 저장방식을 논리적으로 바꾸었을때 기존 애플리케이션은 업무를 바로 수행하기 어려움. 별도 애플리케이션 수정,보완 요구됨</br>
  * __데이터 중복 문제__ :
    - 동일사항에 대해 중복데이터는 __일관성,보안성,경제성__ 측면에서 문제발생 (e.g>학적앱과 수강신청앱에서 같은 학생에 대한 중복된 정보가 있지만 호환되지 않아서 하나의 앱에서 수정시 다른 앱에 적용이 안됨, 또한 데이터정보가 많아질수록 수정,보완도 어렵고, 보안유지도 어려워짐)</br>
  * __무결성 훼손의 문제__
    - 실세계의 데이터는 데이터가 가질 수 있는 가능 범위(제약조건) 포함해야하는데 파일처리시스템은 이런 기능이 없다.(e.g> 수강신청과목 18학점으로 제한)</br>
  * __동시 접근의 문제__ </br>
    - 동일 데이터에 다수 사용자의 접근 허용시 파일처리시스템은 제약시스템이 없기 때문에 일관성이 훼손된다.
    - 은행데이터(1000원)에 두 명의 고객이 동시 접근할 때 고객A는 500원 출금, 고객B는 1000원 입금 할때에 결과는? 
       
### 2. 데이터베이스의 특징

  #### 1. 데이터베이스 사용의 의미
  데이터의 관리에 애플리케이션의 직접접근이 가능했던 파일처리시스템과 다르게 그 중간자로 데이터베이스를 두어 기존의 문제를 없앰
  #### 2. 데이터베이스의 특징
  - 데이터베이스 시스템의 자기 기술성
  - 프로그램과 데이터의 격리 및 추상화
  - 다중 뷰 제공
  - 데이터 공유와 다수 사용자 트랜잭션 처리
    하나의 논리적 잡업을 처리하기 위한 일련의 데이터베이스 명령의 집합 (e.g> 동시접근할 수 없도록 하나의 트랜잭션 업무처리가 완료시까지 데이터를 일시잠금)
  
  #### 3. 데이터베이스 시스템의 구성
<img width="497" alt="Screenshot 2024-02-21 at 1 14 13 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/aa3b1c58-bc99-4429-8ee1-d36dde456761">

값(12), 데이터 (12,오늘,낮 최고기온), 메타데이터 (오늘, 낮 최고기온)

  #### 4. 데이터베이스의 3단계 구조 
  DBMS는 데이터의 추상화를 위해 외부-개념-내부 3단계로 구조화되며, 외부-개념 사상 과정에서 논리적 데이터 독립성, 개념-내부 사상을 통해 물리적 데이터 독립성이 확보된다.
  <img width="464" alt="Screenshot 2024-02-21 at 1 22 30 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ea5709c7-50a7-4982-9c40-863cfa4cb5e8">
<img width="485" alt="Screenshot 2024-02-21 at 1 24 03 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/56500c90-2895-4ef8-9f9c-ba1f77fee654">

### 3. 데이터베이스의 구성요소
  #### 1. 데이터베이스 언어
  1. DBMS는 사용자가 데이터베이스를 쉽게 사용하고 다룰 수 있도록 언어 형태의 인터페이스를 제공
  2. 역할에 따라 종류의 언어로 구분
     - __데이터 정의 언어 DDL__ : 데이터베이스 객체를 생성,수정,삭제하기 위한 언어
     - __데이터 조작 언어 DML__ : 구조화된 데이터에 사용자가 접근 및 조작할 수 있도록 지원하는 언어(검색,삽입,삭제,수정)
  3. 현대 데이터베이스 언어는 자연어와 유사한 형태의 SQL로 표준화
     
  #### 2. 데이터베이스 시스템 아키텍처
  1. 중앙집중 방식: 단일 서버가 클라이언트 장치를 대신하여 작동 (과거 은행시스템)
  2. 분산시스템 방식: 클라이언트 장치 성능 향상으로 자체적인 처리 능력 보유, 클라이언트-서버 데이터베이스 시스템, 유지보수비용 절감 및 이식성 증가
---

# 데이터베이스 모델링 
ER모델
## 데이터베이스 모델링의 이해
### 데이터 관리의 필요
- 비지니스적 관점 : 어떤 데이터를 저장해야 하는가?
- 컴퓨터 프로그래머 관점: 어떻게 데이터를 저장해야 하는가?

### 데이터베이스 시스템 구현과정

<img width="437" alt="Screenshot 2024-03-13 at 2 21 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/58315953-886c-485e-bc21-102b6116a74a"></br></br>

### 데이터베이스 모델링의 개념
  - 데이터의 의미를 파악하고, 데이터와 관여하는 업무프로세스를 개념적으로 정의,분석하는 작업
  - 모델링 단계
  
    <img width="475" alt="Screenshot 2024-03-13 at 2 25 03 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/938c80da-0fac-40f3-a0ce-b37a5b9636a5"></br></br>
    
    - 사용할 데이터를 선별해 DB에 체계적으로 구조화하여 저장,사용할 방법이 필요
    - 데이터 모델 : 의미, 데이터타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합
    - 데이터 모델링: 실세계 일부분을 DBMS 가 지원하는 데이터 모델의 형태로 나타내는 과정

### 데이터 모델링의 단계
#### 1. 개념적 데이터 모델링
- 요구사항 해석 오류 방지
- 실세계 데이터를 개념적으로 일반화시켜, 데이터구조, 데이터타입, 속성, 관계, 제약조건 등을 이끌어내는 과정
#### 2. 논리적 데이터 모델링
- 특정 DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정
- 데이터 정의 언어로 기술된 개념 스키마 생성
#### 3. 물리적 데이터 모델링
- 데이터베이스 파일의 내부 저장구조, 파일 구성, 인덱스, 접근 경로 등을 결정하는 과정

## 사용자 요구사항 분석
### 사용자 요구사항의 필요성
1. 사용자의 요구를 명세하지 않고 데이터베이스 설계 및 개발을 진행하는 경우
- 결과물의 완성도 저하 및 사용자 신뢰도 추락
- 개발후,발생하는 에러 수정에 많은 추가 비용 지출
2. 시스템의 대상이 되는 업무를 분석
- 정보 시스템의 데이터베이스가 신속하고 효과적으로 업무 처리를 지원
- 필요한 데이터를 저장 및 운용할 수 있는 구조개발

### 사용자 요구사항 분석
1. 데이터에 대한 충분한 사전 분석없이 적절한 설계가 불가능
- 데이터베이스의 활용 범위가 확대됨에 데이터베이스의 효율적 운용에 초점
- 데이터베이스의 구조가 점차 복잡해지고 수명 주기가 단축되고 때문에 신속, 정확성이 요구
2. 도출, 분석, 기록 단계로 수행
- 국제 표준화: IEEE-Std-830

### 사용자 요구사항 분석과정
<img width="464" alt="Screenshot 2024-03-13 at 2 40 31 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1f791c01-0f95-4587-8aaa-969511085f71"></br></br>

- #### 요구사항 도출
  - 구축대상, 프로젝트 목표, 범위를 기준으로 조사범위를 결정
  - 업무관계자 인터뷰
  - 외부자료 수집 및 분석
- #### 요구사항 분석
  - 도출된 요구사항의 명확성, 완전성, 모호성 검증
  - 불완전한 부분이 존재할 경우 요구사항 도출단계 재수행
  - 요구사항을 분류하여 통합 또는 분리
- #### 요구사항 기록
  - 요구사항 목록 정리 및 관리자의 승인
  - 정리된 요구사항을 형식에 맞춰 문서화
  - 프로젝트 종료 때까지 반영 여부 지속적 관리 
---

## ER 모델
1. 개념적 모델링 단계에서 사용되는 데이터 모델
2. 실세계의 속성들로 이루어진 개체(entity)와 개체 사이의 관계(relationship)를 정형화 시킨 모델 3. 구성요소 : 개체집합, 관계집합, 속성

<img width="698" alt="Screenshot 2024-03-13 at 3 20 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/58862235-78a2-4d42-a23b-df8c76d78264">


### 개체집합
1. 개체(entity)
- 실세계에 존재하는 다른 객체와 구별되는 유무형의 사물
- 개체를 설명하는 여러 속성들로 구성
2. 개체 집합(entity set)
- 같은 속성을 공유하는 개체들의 모임
  
### 관계집합
1. 관계
- 개체와 개체 사이의 연관성
2. 관계 집합
- 개체 집합간의 전체적 연결관계

### 속성
1. 개체를 구체적으로 설명
2. 속성에 포함될 수 있는 값의 특성에 따라 여러 종류로 구분
- __1)단순속성 vs 복합속성__
  - 단순속성: 더 이상 작은 구성요소로 나눌 수 없는 속성 ('여자'를 쪼개어 '여''자'로 쪼개면 의미잃음)
  - 복합속성 : 더 작은 구성요소로 나눌 수 있는 속성 (생년월일을 년/월/일의 작은 의미단위로 나눌수 있음)
- __2)단일값 속성 vs 다중값 속성__
  - 단일값 속성 : 하나의 개체에 대해 단 하나의 값 만을 갖는 속성 (학생 한명당 하나의 학생번호, 이름을 가짐)
  - 다중값 속성: 하나의 개체에 대해 여러 개의 값을 갖는 속성(학생 한명이 여러개의 전화번호를 가질 수 있다.)
- __3)유도 속성 vs 저장속성__
  - 유도속성 : 다른 속성의 값으로부터 값이 유추될 수 있는 속성 (생년월일로부터 나이 연산 가능함)
  - 저장속성 : 유도 속성을 위해 사용될 수 있는 속성
- __널(null) 속성__
  
<img width="698" alt="Screenshot 2024-03-13 at 3 24 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/397aeee8-b690-4636-9e71-919a4693f98d"></br></br>

- ### 제약조건 (1. 사상수 /2. 참가 제약조건/ 3. 키 속성)
1. 데이터 모델은 데이터, 의미, 구조, 연관성 및 데이터의 조건을 표현하기 위한 도구
2. ER 모델은 개체와 __관계에 대한 표현의 정확성__ 을 위해 데이터가 항상 준수해야 하는 제약조건을 정의할 수 있는 방법을 제공
3. 제약조건(constraints)의 종류
__1. 사상수(mapping cardinality)__ : 한 개체가 다른 개체와 몇개의 관계를 맺을 수 있는지 명시(일대일, 일대다, 다대일, 다대다)
  - __`일대일 1:1` 사상수 표현__
    
    <img width="443" alt="Screenshot 2024-03-13 at 2 58 08 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b6019bbf-db8a-4c12-b573-0cc443d76a76">
    
  - __`일대다 1:N` 사상수 표현__
    
    <img width="481" alt="Screenshot 2024-03-13 at 2 58 45 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6bb47b5e-28ed-4596-bac8-209345d15c20">
    
  - __`다대다 N:N` 사상수 표현__
    
    <img width="454" alt="Screenshot 2024-03-13 at 2 59 15 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/dd2a1b39-9bd7-43b1-8453-00fb71ce8131">

__2. 참가 제약조건__
  1. __전체적 참가__: 어떤 개체 집합의 __모든 개체__ 가 관계 집합에 참여 하는 조건 => 이중실선
     - 교수-과목 사이의 '강의'관계를 맺기위해, 모든 과목은 '교수'가 필요함
     - 교수 없는 과목은 없으니까 => 전체적 참가
  3. __부분적 참가__: 어떤 개체 집합의 __일부 개체__ 가 관계 집합에 참여 하는 조건 => 실선
     - 교수-과목 사이의 '강의'관계를 맺기 위해, 모든 교수가 다 강의를 할 필요는 없음.
     - 연구교수일 경우도 있고, 안식년일 수도 있음 => 부분적 참가
     
<img width="381" alt="Screenshot 2024-03-13 at 3 00 46 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ee5520e6-7c11-4435-af60-5c554f23d4d6"></br></br>

- __3. 키 속성__
1. `키(key)`: 각 개체를 구별하는데 사용되는 `유일한 값`을 가지는 속성의 집합
- 각 개체를 구별하여 찾는 역할
- 관계집합의 특정 관계를 찾는 역할
- 속성값 밑에 밑줄
  
<img width="120" alt="Screenshot 2024-03-13 at 3 01 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b1ea9e2b-b3db-4d79-8935-b49fb0d37b30"></br></br>

### 특수 속성과 관계
1. 관계 집합의 속성: 두 개체 집합의 관계에서 생성되는 값을 저장하는 속성
2. 재귀적 관계: 한 개체 집합이 자기 자신과 관계 집합을 형성하는 관계
   
   <img width="441" alt="Screenshot 2024-03-13 at 3 07 43 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0cc860fc-813d-423e-890d-2a6b20b71f57"></br></br>

### 특수 관계
1. __약한 개체 집합__
- 개체의 존재 유무가 관계를 맺고 있는 개체의 존재에 종속되는 개체 집합
2. __강한 개체 집합__
- 약한 개체 집합과 연결되는 일반 개체 집합


<img width="352" alt="Screenshot 2024-03-13 at 3 09 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/48ebe6bc-6a2f-421e-b2e6-e175278c5137"></br></br>

### ER 모델 기호 (개념적 모델링 관계)
  <img width="500" alt="Screenshot 2024-03-13 at 3 37 50 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/833e6579-26f5-4de8-bd91-4bd261a49d48"></br></br>

<img width="540" alt="Screenshot 2024-03-27 at 10 30 10 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cfb3a98a-db76-42a4-9692-2376dd35b42f">


---

# 관계형 모델 
- 논리적 모델링 단계
- 릴레이션(relation)으로 데이터를 구조화

## 릴레이션의 구성

<img width="643" alt="Screenshot 2024-03-27 at 4 16 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/bb6c0cc3-d212-4629-8e48-e46e1117b8a5">

### 릴레이션 특징 
- __레코드 유일성__ (중복 불가능)
- __레코드 무순서성__ (순서 의미 없음)
- __컬럼의 무순서성__ (순서없고, 이름과 값의 쌍)
- __컬럼의 원자성__ (나눌 수 없는 단 하나의 의미)

### 키 (key) 역할
- 릴레이션의 레코드를 __유일하게 식별하는 값__
- 예) 특정코드를 바꾸려 할때 사용자가 의도하지 않은 컬럼값이 바뀔 수 있으므로 개별적으로 지목할 수 있어야 함 - 키 값 사용
- 속성 : __유일성, 최소성__
- 종류 : 
  - __수퍼키__(유일성 만족) 
  - __후보키__(유일성,최소성 만족, 기본키 후보) 
  - __기본키__(`PK`, 레코드식별 위해 선택된 후보키) 
  - __외래키__(`FK`,참조된 다른 릴레이션의 기본키)

### 무결성 유지를 위한 제약조건
- __영역 제약조건__ : 컬럼에 정의된 영역(domain)에 속한 값으로만 컬럼값이 결정
- __키 제약조건__ : 키는 레코드를 고유하게 식별하는 값으로 구성
- __개체 무결성 제약조건__ : 어떤 기본키 값도 널(null)이 될 수 없음
- __참조 무결성 제약조건__ : 존재하는 레코드의 `기본키`만을 참조 가능

#### 널(NULL) 의 개념 : 없음 또는 0 이 아닌 미지의 값에 대한 표현 (입력된 적 없는 값이나, 적용 불가능한 값)

## ERD 모델을 관계형 모델(RDBMS)로 변환 (논리적 데이터 모델링)
- DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정(릴레이션으로 데이터를 표현하는 모델)
- 데이터 정의 언어로 기술된 개념 스키마 생성
- 논리적 데이터 모델링의 필요
  - 관계형 DBMS(RDBMS)의 구현 모델에 맞춰 데이터의 구조와 관계를 표현
  - 작성된 ERD를 RDBMS가 수용 가능한 구조로 변환

<img width="461" alt="Screenshot 2024-03-27 at 10 31 19 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/104765fc-1b42-4525-bd3d-2c2117a56441">


- 단계 1. __개체 집합__: 개체 집합은 릴레이션으로 변환
- 단계 2. __약한 개체 집합__: 강한 개체 집합의 키 속성을 약한개체 집합의 릴레이션에 포함
- 단계 3. __일대일 관계__: 두 릴레이션 중에서 한 릴레이션의 기본키를 다른 릴레이션에서 외래키로 참조
- 단계 4. __일대다 혹은 다대일 관계__: ‘일’쪽의 기본키를 ‘다’쪽 릴레이 션에서 외래키로 참조
- 단계 5. __다대다 관계__: 관계 릴레이션을 생성하고, 두 릴레이션의 기본키를 각각 참조하는 외래키를 복합키 형태의 컬럼으 로 구성
- 단계 6. __다중값 속성__: 릴레이션의 기본키를 참조하는 외래키와 다중 값 속성으로 별도의 릴레이션으로 구성
- 단계 7. __관계 집합의 속성__: 외래키가 위치한 릴레이션의 컬럼으로 삽입

<img width="507" alt="Screenshot 2024-03-27 at 10 33 24 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a507f1a5-c55f-4852-9420-419aaef40148"></br></br></br>

<img width="465" alt="Screenshot 2024-03-27 at 10 41 36 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/905d770c-3597-4f9d-badc-ac8cd107df04"></br></br></br>

<img width="498" alt="Screenshot 2024-03-27 at 10 41 49 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/503c4b39-df6b-43fe-ac9e-e92655c5335c"></br></br></br>


---
## 관계데이터 연산
1. 관계형 모델을 기반으로 구성된 릴레이션을 사용하여 __새로운 릴레이션을 생성하는 표현__
2. 사용자의 관점에서 필요한 데이터를 릴레이션에서 추출하는 방법을 제공하는 도구
   
<img width="500" alt="Screenshot 2024-03-13 at 5 09 21 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6f4c2087-6730-47c3-9377-b8f3999215f7">

## 관계대수 relational algebra (시험출제)
- 관계 연산을 정의하는 방법
- 주어진 릴레이션에서 필요한 릴레이션을 만드는 연산자(∪, ∩, -, σ, π, x, ⋈, ÷, 집계함수 등)로 구성
- 관계 대수 연산자는 새로운 임시 릴레이션을 생성
- 연산자를 중첩하여 연산 처리 절차를 표현

## 집합 연산자

<img width="517" alt="Screenshot 2024-03-13 at 7 33 47 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/5dd7c4b5-5396-401b-b567-86dc8df377b0">


1. 수학적 집합 이론에서의 이진 연산
- __합집합__: R ∪ S
- __교집합__: R ∩ S
- __차집합__: R – S
- __카티션 프로덕트 연산__: R x S (두 릴레이션에 포함된 레코드간의 모든 조합을 생성하는 이항 연산자 (단순 결합)
  
  <img width="489" alt="Screenshot 2024-03-27 at 10 48 59 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/3e639f7b-43d9-489d-a47a-13725660e38d"><br>

  <img width="500" alt="Screenshot 2024-03-13 at 7 21 06 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/baf76160-4cb2-41a5-a1e1-4bd8961e4cba"><br>

2. 릴레이션은 집합, 레코드는 집합에 포함된 원소
3. 집합 연산자 사용 조건
- 릴레이션 R과 S의 차수가 동일 (차수 : 릴레이션에 속한 컬럼의 갯수)
- 모든 i에 대해 R의 i번째 컬럼의 도메인과 S의 i번째 컬럼의 도메인이 반드시 동일 (같은 순번 컬럼의 도메인이 같아야함)


## 관계 연산자

<img width="515" alt="Screenshot 2024-03-13 at 7 30 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d08fb746-8145-4543-860d-ad491d7b86d4"></br></br>


### < 셀렉트 연산 >

1. 주어진 릴레이션에서 조건을 만족하는 레코드를 갖는 릴레이션을 생성  (R): 대상릴레이션
   
    <img width="275" alt="Screenshot 2024-03-13 at 6 55 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/266a7ff2-1909-47d2-8878-ca768aaa3292"></br>

2. 조건: aΘb 또는 aΘv

|a, b|속성 이름|v|상수 값|
|---|---|---|---|  
|Θ |비교자 {=, ≠, <, >, ≤, ≥}|R|릴레이션 |

3. 조건의 결합: __∧(and)__, __∨(or)__, Not(ㄱ)


<img width="600" alt="Screenshot 2024-03-13 at 7 22 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a03886ce-68aa-460d-a3c8-260a287528c8"></br></br>

<img width="700" alt="Screenshot 2024-03-13 at 7 23 26 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a5e76b79-82a6-4c78-b18e-662ecc623890"></br></br></br>

 
### < 프로덕트 연산 > 

1. 기술된 컬럼만 갖는 릴레이션으로 재구성</br>

<img width="259" alt="Screenshot 2024-03-13 at 6 55 32 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/558c6b72-cc52-4e02-8d2d-ab56b3220316">

2. <컬럼리스트>: A1, A2, ..., An와 같이 R에 존재하는 컬럼을 ,(콤마)로 분리하여 기술, 존재하지 않는 컬럼 넣을 경우 에러발생</br></br></br>


<img width="500" alt="Screenshot 2024-03-13 at 7 24 49 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4ab33755-ba64-437d-a19b-7cbffc541f4d"></br></br>

<img width="550" alt="Screenshot 2024-03-13 at 7 35 52 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/33c4cd55-5b2e-4298-b0d9-3903f16b7044"></br></br>

<img width="469" alt="Screenshot 2024-03-27 at 11 18 48 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/7a61707c-3ef1-4d49-b199-a025a71c4261"></br></br>
- $\sigma$ <sub>직위  =  '부교수'</sub> (교수)  +  $\prod$ 교수이름 = $\prod$ 교수이름($\sigma$ <sub>직위='부교수'</sub>(교수))

</br></br></br>

### < 조인 연산 >
1. 두 릴레이션에서 __조건을 만족하는 레코드를 결합__ 한 레코드로 구성된 릴레이션을 생성
  - 카티시안 연산과 유사 : 카티시안은 모두 결합하지만, 조인연산은 조건을 만족하는 레코드만 결합
  - 조인연산 = 카티시안 연산 + 셀렉트 연산
   
<img width="310" alt="Screenshot 2024-03-13 at 6 57 22 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/73f20193-15f0-47dc-925f-878f97371eee">

Q. `‘컴퓨터과학과’ 소속의 교수`가 강의하는 과목의 `과목명과 과목코드`는?
  - 교수 릴레이션(소속교수), 과목 릴레이션(과목명,과목코드) 이 두 릴레이션을 동시에 조작해야 함.
  - 하나의 연산에 의해 단 하나의 릴레이션으로 만들어져야 하는데 이 경우는 어떻게 해야 하지?
  - 셀렉트, 프로덕트 연산은 하나의 릴레이션에만 적용되는데
  - 두개의 릴레이션에 동시에 적용하고 싶을 때는 카티시안과 조인연산이 필요함
  - 카티시언 프로덕트 하면 (과목 x 교수)
  - 과목 릴레이션에 있는 교수번호와 교수 릴레이션에 있는 교수번호가 중복하여 두컬럼에 생김
  - 교수번호가 같은 것만 선택해 남겨서 정렬하도록 해주기 (셀렌트 연산)
  - $\sigma$ <sub>과목.교수번호 = 교수.교수번호</sub>(과목x교수)
  - 컴퓨터과학과 교수가 담당하는 과목명,과목코드를 추출하려면 이제 어떤 연산을 해야 하나 생각해보기
  - 과목   조인(나비넥타이) <sub>과목.교수번호 = 교수.교수번호</sub>   교수

</br></br></br>

### < 디비전 연산 >
</br></br></br>

### < 집계함수 연산 >
1. 집계 함수를 값들의 집합 또는 레코드의 집합에 적용 하는 연산
  - 계산을 해야하는 연산은 집계함수를 사용

<img width="200" alt="Screenshot 2024-03-13 at 6 58 21 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f6946b20-0d2b-489e-a55c-9b5290ea96d2">

 - x( ): AVG, SUM, MIN, MAX, COUNT등의 집계 함수
 - A: 집계연산을 적용할 컬럼

<img width="452" alt="Screenshot 2024-03-27 at 11 16 59 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/aa3351fe-f383-4343-9c11-6394dfc77979">


2. 레코드 그룹화를 위해 집계 함수 연산자 앞에 `그룹화` 속성을 기술
   
<img width="198" alt="Screenshot 2024-03-13 at 7 11 16 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b28e63c2-d65a-4a63-88f3-d23e0b097a07">

- B:그룹의기준이되는컬럼
- x( ): 집계 함수
- A:집계연산을적용할컬럼
- R: 릴레이션
  
<img width="444" alt="Screenshot 2024-03-27 at 11 17 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/7fbdf737-a321-486f-97c5-9c630795fc51">

---

# sql 1
## 데이터베이스 언어
### 데이터베이스 언어의 필요

<img width="417" alt="Screenshot 2024-04-09 at 8 59 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/77cb9d7b-d95d-4030-bdd9-4c9c72ba7e81">

### SQL의 개요
1. SQL(Structured Query Language)은 `관계대수`에 기초하여 RDBMS의 데이터 관리를 위해 설계된 언어. __관계대수(relational algebra,關係代數)__ 는 컴퓨터 과학의 관계형 데이터베이스의 관계 모델에서, `집합론`과 `1차 논리`에 기반하여 관계(표)로 표현된 데이터를 취급하는 대수적인 연산 체계이다.
2. 1986년 ANSI, 1987년 ISO에서 표준으로 제정, 국제표준을 확장한 독자적버전 존재 e.g)oracle
3. 특징 : 비절차적 언어, 필요한 데이터만 기술, 인간의 언어와 매우 유사하고 간단 명료
 
### SQL의 구성
1. __데이터 정의 언어(DDL: Data Definition Language)__
  - 데이터베이스 내의 객체를 생성,삭제하고 그 구조를 조작하는 명령어의 집합
  - 데이터가 준수해야 하는 제약조건을 기술
  - __CREATE, ALTER, DROP 문__ 등

2. __데이터 조작 언어(DML: Data Manipulation Language)__
  - DDL 에 의해 정의된 테이블에, 데이터를 조작하는 명령어의 집합
  - 데이터에 대한 __CRUD (생성,검색,삭제,수정)__ 명령을 포함
  - __INSERT, UPDATE, DELETE, SELECT 문__ 등

## 1. 데이터 정의 언어 DDL
### 데이터 정의 언어의 개념
1. 데이터베이스 객체를 생성,삭제 또는 구조를 수정하는 명령어의 집합
2. 데이터베이스 __객체의 종류__ : 
  - 데이터 __저장__ - __테이블, 인덱스, 뷰__
  - 데이터 __조작__ - __트리거, 프로시저, 함수__ 등
3. 데이터 정의 명령어의 종류
  - CREATE(객체생성), ALTER(객체수정), DROP(객체삭제)

<img width="450" alt="Screenshot 2024-04-09 at 9 17 13 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a5c30faf-e73c-40ff-bc5a-0d10351a07ef">

### 스키마 정의 CREATE SCHEMA
1. 스키마 = 데이터베이스
2. 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 DB 객체의 집합
3. 스키마 관리방법 : Forward Engineer, SQL 에디터, 내비게이터 패널
#### 스키마 관리 구문 형식
1. 스키마 생성 : CREATE SCHEMA 스키마이름
2. 스키마 삭제 : DROP SCHEMA 스키마이름

### 테이블 정의 CREATE TABLE
1. 새로운 2차원 형태의 테이블을 생성
__구문형식__
```SQL
CREATE TABLE 테이블이름 (
  <칼럼1><데이터타입1>[제약조건1][,
  <칼럼2><데이터타입2>[제약조건2]]
  ...                      [,
  <칼럼n><데이터타입n>[제약조건n]]
  [PRIMARY KEY 컬럼명]
  [UNIQUE 컬럼명]
  [FOREIGN KEY 컬럼 REFERENCES 테이블이름(컬럼)]
)
```
<img width="392" alt="Screenshot 2024-04-09 at 9 28 55 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/5258ddb5-b991-453b-abbf-bdedcd861441">

#### 데이터타입
1. 컬럼이 가질 수 있는 값의 범위, 즉 도메인을 결정
2. 프로그래밍 언어에서의 변수를 생성하는 데이터 타입의 사용목적과 방법이 매우 유사
3. 기본 데이터 타입

<img width="394" alt="Screenshot 2024-04-09 at 9 30 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8f26b987-4f49-4a23-82ed-effd1c74922f">

- 정수 데이터 타입 (TINYINT, SMALLINT,INT, BIGINT)
- 실수 데이터 타입 (고정소수형 DECIMAL(M,N), NUMERIC , 부동소수형 FLOAT, FLOAT(P),DOUBLE)
- 날짜 및 시간 데이터 타입 (DATE, YEAR, TIME, DATETIME, TIMESTAMP)
- 문자 데이터 타입 (CHAR(N): 문자열 저장시 최대길이 N만큼 공백이 포함됨, VARCHAR(N):공백포함 안됨, 가변적, TEXT, CLOB, ENUM)

### 테이블 수정 ALTER TABLE
1. 생성된 테이블에 컬럼을 추가,수정(이름,데이터타입,제약조건)또는 삭제하는 명령
2. 컬럼 삭제 또는 컬럼의 데이터 타입 수정시 데이터 소실 발생하므로 주의요구
3. 테이블 수정방법 (SQL구문, 내비게이터 패널)
4. 테이블 수정구문형식
```SQL
ALTER TABLE 테이블이름
  [ADD COLUMN 컬럼 데이터타입[제약조건]]
  [DROP COLUMN 컬럼이름]
  [CHANGE COLUMN 수정전컬럼 수정후컬럼]
  [MODIFY COLUMN 컬럼 데이터타입]
```

<img width="438" alt="Screenshot 2024-04-09 at 9 42 53 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/9cd4e26f-3ed3-4816-8198-f7983585ffd7">


### 테이블 삭제 DROP TABLE
1. 테이블을 데이터베이스에서 제거
  구문형식 : DROP TABLE

### 제약조건
1. 테이블과 테이블에 존재하는 데이터를 보다 무결하게 관리하기 위한 목적으로 사용
2. DBMS는 테이블 조작 시 테이블에 정의된 제약조건을 만족시키는지 지속적으로 검사
3. DBMS는 적용하려는 제약의 유형에 따라 다양한 제약 조건을 지원

#### 제약조건의 종류
1. __PRIMARY KEY__: 기본키 지정, UNIQUE와 NOT NULL 의 특성
2. __FOREIGN KEY__: 외래키 지정, 참조 컬럼 정의
3. __NOT NULL: NULL__ 이 될 수 없는 컬럼에 지정
4. __UNIQUE__: 동일한 컬럼값을 가질 수 없음을 지정
5. __AUTO_INCREMENT__: 레코드가 추가될 때 자동적으로 속성값이 1부터 1씩 증가되어 입력
6. __CHECK__: 컬럼값이 특정 조건 준수 여부 지정

#### 제약조건의 사용

<img width="421" alt="Screenshot 2024-04-09 at 9 49 00 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/5e24c6a3-59bc-48bb-91f6-8edc70a49c58">

#### 제약조건의 응용

<img width="445" alt="Screenshot 2024-04-09 at 9 49 29 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cdbeb18a-fd3e-4061-a047-6f0972658164">



---

# sql 2
## 2. 데이터 조작언어 DML
### 데이터 조작 언어의 개념
1. DML: Data Manipulation Language
2. 정의된 테이블에 레코드를 삽입,수정, 삭제 및 검색하는데 사용되는 명령어 집합
3. 명령어종류 : INSERT, UPDATE, DELETE, SELECT


### INSERT 문
1. 테이블에 새로운 레코드를 삽입하는 명령문
2. 모든 속성 또는 부분 속성에 대한 속성값을 삽입

#### 구문형식 1
```Sql
INSERT INTO 테이블이름
  VALUES(값1, 값2 ...값n)

INSERT INTO 학과
  VALUES('영어영문학과','인문과학대학','02-3434-xxxx',135
```
#### 구문형식 2 : 컬럼을 명시하고, 칼럼과 value값이 순서대로 매칭됨, 칼럼자체의 순서는 상관없음
```Sql
INSERT INTO 테이블이름 (컬럼1, 컬럼2 .. 컬럼n)
  VALUES(값1, 값2 ...값n)

INSERT INTO 학과(학과이름,단과대학,전화번호,졸업학점)
  VALUES('영어영문학과','인문과학대학','02-3434-xxxx',135
```


### UPDATE 문
1. 조건을 만족하는 레코드의 특정 컬럼값을 수정

#### 구문형식 1
```Sql
UPDATE 테이블이름
  SET컬럼1 = 값1 [컬럼2=값2...컬럼n=값n]
  [WHERE 조건]

UPDATE 학과
  SET주소 = 'http://computer...'
  WHERE 학과이름 = '컴퓨터과학과'
```
#### 구문형식 2 : 
```Sql
UPDATE 테이블이름
  SET컬럼1 = 수식1 [컬럼2=수식2...컬럼n=수식n]
  [WHERE 조건]

UPDATE 학과
  SET잔액 = 잔액*1.02
  WHERE잔액>=50000
```


### DELETE 문
1. 조건에 일치하는 레코드 집합을 테이블에서 삭제할 때 사용하는 명령어

#### 구문형식 
```Sql
DELETE FROM 테이블이름
  [WHERE 조건]

DELETE FROM 교수
  WHERE소속학과 = '행정학과'
```


### SAFE UPDATES 모드
1. WHERE절이 없는 UPDATE/DELETE 문은 테이블의 전체 레코드를 변경/삭제
2. 의도하지 않은 데이터변경/삭제 방지를 위해 MySQL은 SAFE UPDATE모드를 지원
3. 기본키가 아닌 컬럼을 대상으로 수정/삭제 조건을 명시할 경우 실행 여부를 결정
```sql
SET SQL_SAFE_UPDATE =0 또는 1
```

## 데이터 검색(1)
### SELECT 문
1. 한 개 이상의 테이블에서 주어진 조건에 만족하는 레코드를 출력하는 명령문
2. 관계대수의 셀렉션, 프로젝션,조인,카티션 프로덕트 연산자의 기능을 모두 포함하는 명령문
3. 필수적 절인 SELECT 절과 부가적 목적으로 사용가능한 여러절을 혼합해 검색기능을 구체화

### SELECT 문 구문형식
```sql
SELECT[DISTINCT]컬럼1,컬럼2...컬럼n
  FROM 테이블1[INNER JOIN|OUTER JOIN]
       테이블2[INNER JOIN|OUTER JOIN]
       ON조인 조건1
       테이블3[INNER JOIN|OUTER JOIN]
       ...
  [ON조인 조건식]
  [WHERE 조건식][중첩질의]
  [GROUP BY 칼럼1,컬럼2,...컬럼n]
    [HAVING조건]
  [ORDER BY 컬럼1[ASC|DESC],...컬럼n[ASC|DESC]]
```
#### SELECT문의 각 절의 기능
1. SELECT절 - 결과에 포함되는 컬럼을 지정
2. FROM절 - 질의를 적용할 테이블을 지정
3. ON/WHERE 절 - 조인조건/검색할 레코드조건을 지정
4. GROUP BY절 - 레코드를 그룹화하기 위한 그룹조건을 지정

### 단순질의문
1. 레코드를 제한하지 않고 전체 테이블을 검색하는 SELECT문으로 WHERE절이 없는 질의문

#### 구문형식 1
```sql
SELECT 컬럼1,컬럼2,...컬럼n
  FROM 테이블

SELECT 소속학과
  FROM 교수

SELECT DISTINCT 소속학과
  FROM 교수
```
#### 구문형식 2 : *이용한 전체선택
```sql
SELECT*
  FROM 테이블
```

### 조건질의문
1. 산술연산식,함수 등을 사용해 표현한 조건을 WHERE절에 기술하여 조건을 만족하는 레코드만 검색하는 SELECT문 (산술연산자+-/*%,비교연산자=><!=<>,논리연산자AND OR || NOT)
2. WHERE절은 UPDATE,DELETE 문에서도 동일하게 적용

```sql
SELECT 과목명,학점,선수과목 FROM 과목
  WHERE 이수구분 ='전공필수'

SELECT 학생번호,학생이름,전화번호,나이 FROM 학생
  WHERE 성별='남'AND생년월일 <'2000-1-1'
```

### 데이터정렬 ORDER BT [ASC|DESC]
1. ORDER BY절을 사용
2. 검색 결과를 특정 컬럼에 대해 오름차순(ASC) 또는 내림차순(DESC)으로 정렬

#### 구문형식
```sql
SELECT문 형식
  ORDER BY 컬럼1 [ASC|DESC]
            ...
           컬럼n [ASC|DESC]

SELECT* FROM 계좌
  ORDER BY 잔액 ASC

SELECT* FROM 계좌
  ORDER BY 잔액 DESC
```

### 특수연산자 BETWEEN, IN, LIKE
1. 범위포함 여부, 부분일치 여부, 포함 여부 등 관계형 데이터베이스에서만 사용되도록 고안된 연산자

<img width="433" alt="Screenshot 2024-04-10 at 2 23 30 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c196f501-a7f7-449a-aec2-17c8788ec420">

```sql
SELECT 계좌번호,잔액,학생번호 FROM 계좌
  WHERE 잔액>=200000 AND 잔액<=400000

SELECT 계좌번호,잔액,학생번호 FROM 계좌
  WHERE 잔액 BETWEEN 200000 AND 400000
```
```sql
SELECT 교수이름,직위,소속학과 FROM 교수
  WHERE 소속학과='컴퓨터과학과' OR 소속학과='행정학과'OR 소속학과='법학과'

SELECT 교수이름,직위,소속학과 FROM 교수
  WHERE 소속학과 IN ('컴퓨터과학과','행정학과','법학과')
```
```sql
SELECT 과목코드,과목명,이수구분 FROM 과목 
  WHERE 과목코드='COM'

SELECT 과목코드,과목명,이수구분 FROM 과목 
  WHERE 과목코드 LIKE'COM%'
```


### 함수
#### 함수의 개념
1. 특정 목적을 수행하도록 사전에 정의된 연산 및 기능을 수행한 후 결과값을 반환하는 명령어집합
2. 상용 DBMS는 검색결과가 사용자에게 여러형태로 사용되도록 여러 데이터타입에 대한 다양한 함수를 제공(MySQL 기준) 숫자함수, 문자함수, 날짜 및 시간함수

#### 숫자함수

<img width="431" alt="Screenshot 2024-04-10 at 2 37 01 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/bf13df4b-e489-4948-947f-a60f9387b76e">

#### 문자함수

<img width="431" alt="Screenshot 2024-04-10 at 2 40 33 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/2ee721a8-06f7-4dda-8864-8f1a799af2be">

#### 날짜 및 시간함수

<img width="431" alt="Screenshot 2024-04-10 at 2 40 57 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e4a455e4-e8b7-47b1-a821-afc7386e1ed7">

#### 함수의 사용
```sql
학생번호 앞 6자리만 출력하고 성별뒤에는 '성'을 붙이기
SELECT SUBSTRING(학생번호,1,6),학생이름,
       CONCAT(성별'남')
       FROM 학생 
```

#### 집계함수
1. 특정 컬럼에 집계함수를 통해 다양한 통계연산을 수행할 수 있는 기능
2. SELECT절 또는 HAVING 절 뒤에 함수(COUNT(),SUM(),AVG(),MAX(),MIN())
3. 집계함수의 종류 (COUNT(),SUM(),AVG(),MAX(),MIN())

```sql
SELECT COUNT(단과대학)
  FROM 학과

단과대학 중복 없애기
SELECT COUNT(DISTINCT단과대학)
  FROM 학과

AS로 컬럼 네이밍
SELECT COUNT(DISTINCT단과대학) AS 단과대학수
  FROM 학과
```

---

# sql 3
## 데이터 검색(2)
### 그룹질의 Group Query
1. 특정기준으로 레코드를 `그룹화`하고 각 레코드그룹에 대해 `집계합수를 적용`하는 질의
2. [주의]SELECT절에 그룹의 기준과 집계함수 이외의 컬럼은 포함될 수 없음

```sql
SELECT 질의
  GROUP BY 컬럼

SELECT 소속학과,COUNT(*)AS교수수
  FROM 교수
  GROUP BY 소속학과

컬럼의원자성을 위배한 예시, 교수이름 쓰면 안됨
SELECT 소속학과,COUNT(*)AS교수수,교수이름 <-(X)
  FROM 교수
  GROUP BY 소속학과
```

### HAVING 절
1. 그룹 질의의 결과 레코드에 대해 `출력조건`을 기술하기 위한 절
2. 조건기술절 (WHERE:레코드에 대한 조건기술, HAVING:집계결과레코드에 대한 조건기술)

#### 2개이상 전공신청한 학생(학생번호,신청전공수) 출력
```sql
SELECT 학생번호,COUNT(*)AS신청_전공수
  FROM 전공
  GROUP BY 학생번호

집계코드 출력조건 기술 (전공2개인 학생만)
SELECT 학생번호,COUNT(*)AS신청_전공수
  FROM 전공
  GROUP BY 학생번호
    HAVING 신청_전공수>=2
```

### 중첩질의
1. SELECT문 내부에서 독립적으로 실행 가능한 또 다른 SELECT문이 내포되어 있는 질의
2. 일반적으로 내부질의 처리결과를 외부질의에서 재사용
3. 중첩질의 종류
- `FROM절`에서의 활용 : FROM절에서 결과집합을 SELECT해서 재검색
- `WHERE절`에서의 활용 : WHERE절에서 결과집합을 활용해 외부질의에서 레코드 출력여부결정, IN,NOT IN, EXISTS, NOT EXSISTS사용

#### 구문형식1
```sql
SELECT 컬럼1, 컬럼2,...컬럼n
  FROM(SELECT 컬럼1,컬럼2,...컬럼m FROM테이블 WHERE 조건)
  WHERE 조건

SELECT 소속학과,AVG(연봉) AS평균연봉
  FROM 교수
  GROUP BY 소속학과

SELECT MAX(d.평균연봉) AS 평균연봉
  SELECT 소속학과,AVG(연봉) AS평균연봉
    FROM 교수
    GROUP BY 소속학과 AS d
WHERE(d.평균연봉)<70000000
```
#### 구문형식2
```sql
SELECT 컬럼1, 컬럼2,...컬럼n
  FROM 테이블1
  WHERE 컬럼i 연산자(SELECT 컬럼j FROM테이블2 WHERE 조건)


'생활과학과' 소속학생 중 수강신청하지 않은 학생의 학생번호 출력하기
1. 생활과학과 학생번호 선택
SELECT 학생번호
  FROM 전공
  WHERE 학과이름='생활과학과'

2. A의 학생번호를 가지고 수강 B에 있는지 없는지 확인하기
SELECT 학생번호
  FROM 전공 AS A
  WHERE 학과이름='생활과학과' AND
    NOT EXISTS(SELECT B.학생번호 FROM 수강B WHERE A.학생번호=B.학생번호)
```

### 조인질의 : SQL에서 가장많이 사용
1. 테이블 간의 관련성을 이용해 두개 이상의 테이블에서 데이터를 검색하는 질의 기법
2. ER 모델링 및 정규화 기법으로 여러 테이블로 분리된 정보를 통합해 검색시 유용
3. 조인질의 종류(__내부조인,외부조인__)

#### 내부조인
1. 두개 이상의 테이블에서 조인조건을 만족하는 레코드만 결합해 출력결과에 포함하는 연산
2. 조인조건은 WHERE절이 아닌 ON절에 기록
3. ANSI SQL표준과 사실상의 표준인 Oracle사가 제안한 조인형식이 사용

```sql
SELECT 컬럼1,컬럼2,...컬럼n
  FROM 테이블1 INNER JOIN 테이블2
  ON 조인조건1
  [WHERE 조건]

나이가 30세이상인 학생(학생이름,나이,학생소유 계좌번호,잔액)출력하라
1. 학생테이블에서 계좌테이블에서 활요하기 위해 학생번호도 출력
SELECT 학생이름,나이,학생번호
  FROM 학생
  WHERE 나이>=30

2-a. ANSI 표준방법, 구체적으로 어느테이블에서 검색하는지 명시할것
SELECT 학생.학생이름, 학생.나이, 계좌.계좌번호, 계좌.잔액
  FROM 학생 INNER JOIN 계좌  (두개의 테이블(학생,계좌) 조인)
  ON 학생.학생번호 = 계좌.학생번호 (조인조건기술: 학생번호가 같은 곳)
  WHERE 나이>=30 (학생나이 30세이상)

2-b. ORACLE 방법, 구획업이 중복적 사용
SELECT 학생.학생이름, 학생.나이, 계좌.계좌번호, 계좌.잔액
  FROM 학생, 계좌  (콤마사용으로 구분된 테이블은 자동으로 CROSS JOIN함)
  WHERE 학생.학생번호 = 계좌.학생번호 AND 나이>=30 (ON절 없이 WHERE절에 조건 모두 기술)
```

#### 자연조인
1. 두개 이상의 테이블을 하나의 테이블로 결합하는 내부조인과 매우 유사한 기능
2. 두 테이블에 동일한 이름의 컬럼에 대해 값이 같은 레코드를 결합하는 내부조인
3. 컬럼의 조건이 같은 것들만 조인하기 때문에 ON절에 추가조건문 필요없음, 조인조건 만족하지 않으면 출력하지 않음

```sql
SELECT 컬럼1,컬럼2,...컬럼n
  FROM 테이블1 NATURAL JOIN 테이블2
  [WHERE 조건]
```

#### 외부조인
1. 내부조인(inner join)은 조인조건에 일치하는 레코드만 결합하여 결과를 생성(정보손실가능성있음)
2. 외부조인은 조인조건에 맞지 않는 레코드도 질의결과에 포함시킴 (NULL로 넣어줌)
3. 외부조거인의 종류(__왼쪽외부조인,오른쪽외부조인,완전외부조인__)

<img width="446" alt="Screenshot 2024-04-10 at 4 22 52 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f722657d-9242-4933-af97-1e423aa0ff0c">

```sql
SELECT 별칭1.컬럼1,별칭1.컬럼2,...별칭1.컬럼n
       별칭2.컬럼1,별칭2.컬럼2,...별칭2.컬럼n
  FROM 테이블1 AS 별칭1
       LEFT|RIGHT [OUTER] JOIN
       테이블2 AS 별칭2
  ON 별칭1.컬럼i = 별칭2.컬럼j
  [WHERE 절]
```

학생의 학생번호, 학생이름과 그 학생이 수강신청한 과목의 과목코드, 신청시각을 출력하시오
단, 수강신청하지 않은 학생도 결과에 포함시키고, 과목코드를 기준으로 오름차순 정렬한다.
(학생테이블 다 출력 후 수강테이블에서 일치하는 것만 출력, 왼쪽 외부조인이니 학생기준으로 다 출력되고, 수강쪽 조인결과에 없는 값은 NULL로 출력됨, 내부조인이라면 출력되지 않음)
```sql
SELECT A.학생번호, A.학생이름, B.과목코드, B.신청시각
  FROM 학생 AS a LEFT OUTER JOIN 수강 AS B (학생테이블기준으로 조인)
  ON A.학생번호 = B.학생번호
  ORDER BY B.과목코드 ASC
```

#### 셀프조인
1. 한 테이블이 자기 자신과 조인되는 형태
2. 동일한 이름의 테이블에 대한 조인이므로 반드시 테이블 이름에 대한 별칭사용이 의무적

```sql
SELECT 별칭1.컬럼1,별칭1.컬럼2,...별칭1.컬럼n
       별칭2.컬럼1,별칭2.컬럼2,...별칭2.컬럼n
  FROM 테이블1 AS 별칭1 INNER|OUTER JOIN 테이블2 AS 별칭2
  ON 조인조건
  [WHERE 절]
```

과목의 과목코드, 과목명 그리고 그 과목의 선수과목의 과목코드,과목명을 모두 출력하시고
단, 선수과목이 없는 과목도 결과에 포함시킨다.
```sql
SELECT B.과목명, B.과목코드
       A.과목명 AS 선수과목명, B.과목코드 AS 선수과목코드 (테이블 A 컬럼을 별칭으로 바꿈)
  FROM 과목 AS A RIGHT OUTER JOIN 과목 AS B (과목을 자기자신과 조인 이름은A,B)
  ON A.과목코드 = B.선수과목코드
  [WHERE 절]
```

## 뷰의 사용
### 뷰의 개념
1. 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블(virtual table)
- 데이터 독립성: 원본 테이블 구조가 바뀌어도 뷰를 이용한 작업은 정의만 변경되어 응용프로그램에 영향없음
- 데이터 보안: 사용자에게 원본 테이블의 일부 컬럼에 대한 접근을 허용해 보안효과
- 다양한 구조의 테이블 사용: 사용자 요구사항에 맞는 테이블 구조제공
- 작업 단순화: 복잡한 질의문을 뷰로 단순화
- 데이터 무결성: WITH CHECK OPTIOPN 을 이용해 뷰 생성에 위배되는 수정작업 거부

### 뷰의 생성
1. 생성되는 뷰의 구조는 SELECT 문의 결과로 결정
```sql
CREATE VIEW 뷰이름 AS
  (SELECT 컬럼1,컬럼2,...컬럼n FROM 테이블 [WHERE조건])
[WITH CHECK OPTIOPN]
```
컴퓨터과학과 소속의 학생정보와 학과이름, 이수학점을 출력하는 '컴퓨터과학과_학생' 뷰를 생성하시오
(학생,전공 테이블 ON필요 없이 NATURAL JOIN으로 조인)
```sql
CREATE VIEW 컴퓨터과학과_학생 AS
(SELECT 학생*, 전공.학과이름, 전공.이수학점
FROM 학생 NATURAL JOIN 전공
WHERE 전공.학과이름='컴퓨터과학과'
```

### 뷰의 수정, 삭제
1. 뷰의 수정은 생성과 동일하게 새로운 SELECT 문의 결과로 변경
```sql
ALTER VIEW 뷰이름(컬럼1,컬럼2,...컬럼n) AS
  (SELECT 컬럼1,컬럼2,...컬럼n FROM 테이블 [WHERE조건])
```
```sql
DROP VIEW 뷰이름
```

### 뷰를 이용한 데이터 검색
1. 뷰는 가상의 테이블이므로 데이터조작은 테이블 조작과 동일하게 수행
구문형식
```sql
SELECT 컬럼1,...컬럼2 FROM 뷰이름
  WHERE 조건
```
실행형식
```sql
SELECT 컬럼1,...컬럼2 FROM 뷰이름
  WHERE 조건 AND 뷰 정의조건
```

### 뷰를 이용한 데이터 조작
1. 뷰에 대한 INSERT문은 원본 테이블에서 실행
- PRIMARY KEY, NOT NULL 등의 제약사항이 위배되는 경우 삽입 불가능
- 원본 테이블에 존재하는 컬럼이지만 뷰에는 없는 컬럼에 삽입하는 경우 실행 불가능
- `조인 질의` 또는 `그룹 질의`가 적용된 뷰는 데이터 삽입,수정이 불가능 (복잡한 셀렌트문 사용 불가능)
- WITH CHECK OPTION 이 적용된 뷰는 위배되는 사항은 없지만 뷰에 맞지 않는 조건일 경우 실행 불가능
---

# 정규화
## 좋은 릴레이션과 나쁜 릴레이션
### 나쁜 릴레이션

<img width="565" alt="Screenshot 2024-04-10 at 10 18 13 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/281845dc-a017-4e89-a2b7-0c0af5eceb1d">

1. 데이터의 중복 (일관성유지 어려움, 저장공간낭비)
2. 갱신이상 (삽입이상 - 등급,할인율만 업데이트못함, 삭제이상- 등급,할인율만 삭제 못함, 수정이상- 할인율을 일일히 수정해줬는데, 다른것은 수정실패)

### 좋은 릴레이션

<img width="447" alt="Screenshot 2024-04-10 at 10 20 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/47befb90-ac08-46cd-a638-a6aa4299500e">

## 함수의 종속성
### 함수적 종속성의 정의
1. 릴레이션 인스턴스를 분석하여 속성들 간의 연관관계를 표현한 것
2. 릴레이션의 효율성을 향상시켜 좋은 릴레이션으로 변환하는데 이용되는 중요한 개념

<img width="426" alt="Screenshot 2024-04-10 at 10 23 02 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c33a943b-acda-4031-928c-45fd904c8462">

__서로 다른 두개의 레코드에 대해 컬럼값이 같으면 다른 컬럼값도 같아야 한다. 그러면 X가 Y를 종속한다.__

<img width="387" alt="Screenshot 2024-04-10 at 10 25 02 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b407bc09-bea1-47a1-af54-d361c8097d26">

### 함수적 종속성의 확장
1. 함수적 종속성은 릴레이션의 효율성 여부에 중요한 판단기준
2. 그러나 릴레이션의 인스턴스만으로 내재된 모든 함수적 종속성을 찾아내기 어려움
3. 판별되지 않은 모든 함수적 종속성을 찾기 위해 __추론규칙__ 사용해 함수적 종속성을 확장
4. 클로저(Closuere) 판별된 함수적 종속성 집합으로부터 유추할 수 있는 모든 함수적 종속성 집합

### 함수적 종속성 추론규칙
1. 암스트롱 공리(Armstrong's axiom)

<img width="458" alt="Screenshot 2024-04-10 at 10 29 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0a63a6b3-da6e-4aef-9fce-7936eb6a517b">

<img width="625" alt="Screenshot 2024-04-10 at 10 43 56 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/7d6be870-4333-4da2-9c6b-cf53b80f842f">

### 카노니컬 커버
1. 함수적 종속성 추론 규칙으로 확장된 클로저에는 자명한 종속성(A->A 의미 당연)과 중복된 종속성(X->AB, X->B 의미 여러번 존재)을 포함
2. 불필요한 함수적 종속성을 제거한 표준형으로 변환 후 정규화를 수행
3. 표준형 조건
- F의 모든 함수적 종속성의 오른편속성(종속자)은 반드시 1개 ({x,y}->{z}는 표준형, {x}->{a,b}는 표준형 아님)
- F에서 어떤 함수적 종속성을 제거했을 때, 그 집합이 F와 동등한 집합이 불가능 (불필요한 가지치기를 하지 않음)

## 정규화
### 정규형의 개념
#### 정규형
1. 이상 현상을 최소화 하도록 특정 조건을 갖춘 릴레이션의 형식
2. 정규형의 분류 (제 1,2,3,BC,4,5 정규형 , 현업에서는 보통 4,5 정규형은 잘 안씀)

#### 정규화의 목적
특정 정규형의 조건을 만족하도록 릴레이션과 속성을 재구성하는 과정
1. 정규화의 기능
- 데이터베이스 내에 모든 릴레이션을 효과적으로 표현
- 보다 간단한 관계 연산에 기초해 검색 알고리즘을 효과적으로 작성할 수 있도록 지원
- 바람직하지 않은 삽입,수정,삭제등의 이상발생 방지
- 새로운 형태의 데이터 삽입시에 릴레이션 재구성 필요성을 축소

### 제 1 정규형
1. 가장 조건이 단순한 정규형
2. 관계형 모델 조건에 따라 자동 적용되는 정규형
3. 정의 : 릴레이션 스키마에서 정의된 모든 속성의 도메인이 __원자값__ 을 갖는 상태 ( 컬럼의 value는 하나만 갖을 수 있음)

제 1 정규화가 필요한 릴레이션 : 첫번째 세번째 레코드의 입항시간, 출항시간의 값이 두 개임

<img width="419" alt="Screenshot 2024-04-10 at 10 55 54 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6ae82c86-8501-4e6b-a0f9-fb47c764845b">

#### 함수적 종속성 판별단계
제 1 정규화 한 릴레이션의 함수적 종속성 판별하기

<img width="661" alt="Screenshot 2024-04-10 at 10 59 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e1c4d1c9-be2a-4edd-b34a-a94de4d1b7d2">

한 릴레이션에서 많은 종속성을 찾아낼 수 있는데 이를 다이어그램으로 나타내면 이해가 쉬움

#### 함수적 종속성 다이어그램 (FDD)
1. 릴레이션 내의 속성간의 종속 관계를 직관적이고 이해하기 쉽게 도식화 한 표현방식 
- 직사각형: 속성 또는 속성집합
- 화살표: 함수적 종속성

<img width="372" alt="Screenshot 2024-04-10 at 11 03 19 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6695ba34-28f4-49f7-9201-b8b717a286af">

<img width="649" alt="Screenshot 2024-04-10 at 11 05 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0e899fdf-0a67-404a-b01b-386fe668d6b2">


### 제 2 정규형
1. 릴레이션이 제 1 정규형을 만족하고 기본키의 부분집합이 특정 속성을 종속하고 있지 않은 상태
2. 정의: 주어진 릴레이션의 인스턴스가 기본키가 아닌 속성들이 __기본키에 완전히 종속되어 있는 상태__

<img width="432" alt="Screenshot 2024-04-10 at 11 07 38 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/7328df34-1fb1-41d2-bb81-c1f88f7b95bf">

<img width="325" alt="Screenshot 2024-04-10 at 11 14 59 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c0953f16-626f-4f51-9801-d4d9d879a62f">


<img width="679" alt="Screenshot 2024-04-10 at 11 09 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d4a974e9-89f6-4d93-b676-555c1fa42364">

<img width="490" alt="Screenshot 2024-04-10 at 11 12 41 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ecf8445a-ab4a-4c86-8546-1fdaaa773370">

### 제 3 정규형
1. 정의: 릴레이션이 제 2정규형을 만족하고, 기본키가 아닌 속성들이 어떤 키에도 이행적으로 종속되지 않은 상태
2. 이행적 종속성: X->Y 이고 Y->Z 이면 X->Z이다.

<img width="461" alt="Screenshot 2024-04-10 at 11 17 23 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d55397f3-b3be-4f98-828f-3edbf0eabbe1">

<img width="450" alt="Screenshot 2024-04-10 at 11 17 36 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ce4b1918-d2c2-4ed0-bd75-156f14bece87">

<img width="443" alt="Screenshot 2024-04-10 at 11 17 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/90e0c1d2-7bc9-460c-b611-5c5beebdb674">

<img width="430" alt="Screenshot 2024-04-10 at 11 18 26 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e62e3361-7fe4-441c-a280-d370974056f8">


### BC 정규형
1. 정의 : 릴레이션이 제 3정규형을 만족하고 릴레이션에 성립하는 X->Y 형태의 모든 함수적 종속성에 대하여 X가 수퍼키인 상태
2. 입출항관리 릴레이션의 함수적 종속성
- {도크번호,입항시간} -> {목적}
- {도크번호,입항시간} -> {출항시간}
- {목적} -> {도크번호}   __목적은 기본키, 후보키, 수퍼키 아닌 일반속성임__

<img width="375" alt="Screenshot 2024-04-10 at 11 22 33 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6af1aa23-9c3a-4514-aef4-7924e235169a">

<img width="373" alt="Screenshot 2024-04-10 at 11 23 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c53102d9-5c44-4829-86d6-2f528f2787ba">

<img width="421" alt="Screenshot 2024-04-10 at 11 24 09 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b2159f75-e648-4d44-af92-fe7871cac8f2">


제 1 정규화가 된 릴레이션에서 정규화 시작하면

<img width="423" alt="Screenshot 2024-04-10 at 11 25 20 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/843306aa-2623-4127-9955-d01bc13e8119">

정규화 결과가 이렇게 나옴
무손실 분해를 통해 BC 정규화까지 된 4개의 릴레이션을 조인하면 원래의 릴레이션으로 만들 수 있음

<img width="467" alt="Screenshot 2024-04-10 at 11 25 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a88cc9f5-71ec-46bb-8edb-c8bd9247555d">

### 역정규화
1. 정규화
- 릴레이션 분할을 통해 데이터의 중복성을 최소화하는 과정
- 사용과정에서 많은 조인연산을 유발 (DBMS 힘들어하고 사용자에게 데이터 전달 늦어짐)
2. 역정규화 (현업에서 성능이 중요할때 수행함)
- 정규화의 반대과정
- 정규화를 통해 분리되었던 릴레이션을 통합하는 재조정을 수행하고 정보의 부분적 중복을 허용함
- 데이터 접근 성능 개선이 목적임
3. 정규화되지 않은 스키마와 역정규화 스키마는 구조적, 효율성 측면에서 다름
