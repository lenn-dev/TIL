# 1번 
## (1) 프로세스의 상태 5가지
1.	생성(New)상태 : 프로세스는 커널 영역에 PCB(Process Control Block)를 부여 받은 상태이다. 프로세스 생성되고 보통 준비나 보류상태로 전환된다. 프로세스 생성후에 메모리공간을 먼저 확인하고, 공간이 충분하면 주소공간을 할당한 후 프로세스를 준비상태로 바꾸어 준다. 
2.	준비(Ready)상태 : 프로세스가 CPU 할당을 받아서 실행되기를 기다리는 상태이다. 다중 프로세스를 위해 큐, 리스트가 사용된다. 운영체제에 의한 CPU에 할당 우선순위를 정하는 것이 CPU스케줄링이다.
3.	실행(Run)상태 : 준비 큐에 준비 상태이던 프로세스가 CPU를 할당 받게 되면(Dispatch) 되어 실행된다. 실행상태의 프로세스는 CPU 스케줄링에 의해 CPU를 반환하고 준비상태로 돌아갈 수 있다. (선점형 방식) 또한 진행 상태인 작업이 입출력 요청이 필요하여 시스템 호출(System Call)을 하면 입출력 프로세스가 종료될 때까지 대기상태로 바뀐다. 
4.	대기(Wait)상태 : 실행상태인 프로세스가 입출력을 요청하거나, 바로 확보 불가능한 자원을 요청하면 CPU를 반납하고 요청 이벤트가 완료될 때까지 기다리는 상태이다. 이벤트는 사용자 입력, 입출력 완료,시간 지연 등의 다양한 상황을 말한다. CPU에 비해 느린 입출력 작업일 경우엔 대기상태로 있다가 입출력 완료 인터럽트 신호를 받고 재개 조건이 만족되면 준비상태로 전환된다.
5.	종료(Exit)상태 : 프로세스의 실행이 끝났거나 강제로 종료 되었을 때 종료 상태로 전환된다. 종료된 프로세스는 시스템에서 제거된다.

## (2) 문서작성 프로그램의 프로세스 상태 변화 구체적 설명

<img width="600" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/1f781986-e43e-450a-9e38-915c7ce0faa1">

 
- 생성 --> 준비 : 문서 작성 프로그램을 실행 명령을 내리면, 프로세스가 생성되고 초기화 된다. 필요한 자원이 할당된 후  바로 준비상태로 들어가 CPU할당을 기다린다.
- 준비 --> 실행(Dispatch):  준비 큐에 있던 프로세스가 CPU를 할당받고 디스패치(Dispatch) 되어 문서 작성 프로그램이 열린다.
- 실행 -> 대기(Block):  문서작성 프로그램이 실행 중, 파일열기를 통해 작성하던 보고서 파일을 불러오기를 명령했다. 디스크에 저장된 보고서 파일(디스크 입출력)을 읽어 들이고 출력하기 위해서 시스템 호출을 하고, 문서작성 프로그램은 입출력 요청이 완료될 때까지 대기상태로 바뀐다. 이 파일을 불러오는 동안 문서작성 프로그램이 실행상태로 CPU를 점유한 채 기다리게 되면 CPU 활용에 있어 비효율적이 되므로, 대기상태로 전환한 뒤, 그동안 CPU는 대기큐에 다른 프로세스가 있다면 먼저 실행한다.
- 대기 -> 준비(Wake up): 입출력 작업이 끝나게 되면 대기상태로 전환된 프로세스가 재개조건이 만족되어(wake up) 준비상태가 된다.
- 준비 --> 실행(Dispatch): CPU가 다른 프로세스에 의해 점유 중이라면 할당을 기다리고, 그렇지 않다면 CPU를 할당받고, 디스패치(Dispatch) 되어 실행상태가 된다. 디스크에 저장된 보고서를 메모리로 받았으므로 문서 프로그램이 실행되고 화면에 보고서가 출력된다.
- 생성 --> 준비 : 보고서를 수정, 보완하면서 추가 작성한다. 문서 작업 중에 키보드로 타이핑한 결과가 모니터(단말기)에 즉각 출력되야 하는데, 이러한  빠른 응답 요구하는 단말기 입출력은 파일을 불러오기 위한 디스크커 입출력보다 우선순위가 높아 지연이 없다.
- 생성 --> 준비 :  보고서 작성을 완성한 뒤 저장명령을 내리면 프로세스가 생성되고 준비상태가 되어 CPU할당을 기다린다.
- 준비 --> 실행 :  CPU 할당을 받고, 실행된다.
- 실행 -> 대기 :  입출력 요청에 의해 문서 프로그램은 대기 상태로 전환되어 저장 요청이 완료될 때까지 대기한다.
- 대기(보류) -> 준비 : 문서가 디스크에 저장 작업이 끝나게 되면 작업완료 인터럽트 시그널을 받고 대기에서 준비상태가 된다.
- 준비 --> 실행 : CPU할당을 받고 실행된다. 문서 프로그램에 저장되었다는 알림이 뜬다
- 종료 : 메뉴에서 종료버튼을 누르게 되면 종료상태로 변하게 되고 시스템에서 삭제된다.





# 2. 번 (1)(2) 
## (1) SJF프로세스 수행 순서와 구체적 시각과 함께 표현 
## (2) 각 프로세스의 반환시간, 평균반환시간 계산

<img width="700" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/fb38ea3d-c477-4ed0-8bdc-25007285a03d">

 
## SJF (Shortest Job First)
- 준비큐에 들어와 있는 프로세스 중에 실행시간이 짧다고 추정되는 프로세스를 먼저 디스패치하여 자원 할당하는 알고리즘이다.
- 비선점 방식의 알고리즘이기 때문에 일단 하나의 프로세스가 시작되면 종료될 때까지 방해할 수 없다.
- 주어진 도착시간과 CPU 사이클 조건을 바탕으로 SJF 알고리즘으로 적용해 보자. 5개의 프로세스의 도착시간이 같다고 가정한다면 CPU사이클이 짧은 순서인 C-> E-> B-> A-> D 순으로 실행될 것이나, 주어진 조건은 도착시간이 다르다.
- 0 초 : A 프로세스가 먼저 실행된다. 비선점 방식이기 때문에 A의 작업이 완료될 때까지 방해받지 않고 실행된 후 4초 후에 종료된다.
- 2 초 : B 프로세스 도착. 비선점 방식의 알고리즘이라 A 프로세스 종료 시까지 대기한다.
- 4 초 : A의 작업이 종료되었을 때 준비 큐에 대기하고 있는 B가 CPU를 할당 받고 실행된다.
- 5 초 : C 도착해서 준비 큐에서 대기 (비선점이라B는 실행 중)
- 6 초 : D 도착해서 준비 큐에서 대기 (비선점이라B는 실행 중)
- 7 초 : E 도착해서 준비 큐에서 대기, B 프로세스 종료되었다. 
  준비 큐에 대기중인 작업 시간을 비교하면 C[1] < E[2] < D[5] 가장 짧은 작업인 C 를 실행시킨다.
- 8 초 : C 프로세스 종료되고, 준비 큐에서 가장 짧은 작업인 E 가 실행된다.
- 10 초 : E작업이 종료되고, 준비 큐에 남아있는 마지막 프로세스인 D 가 CPU를 할당 받고 실행된다.
- 대기시간은 각각 A: 0,  B: 2,  C: 2,  D: 4,  E:1
- 반환시간은 각각 A: 4,  B: 5,  C: 3,  D: 9  E: 3
- 평균 대기시간은 (0+2+2+4+1)/5 = 1.8
- 평균 반환시간은 (4+5+3+9+3)/5 = 4.8
- SJF 는 FCFS 알고리즘에서의 호위효과 문제가 해결되었지만, 실행시간이 긴 프로세스의 경우CPU를 영원히 할당 받지 못하게 되어 기아현상이 발생할 수 있다.
- 실행시간을 추적하지만 사실 이 작업이 예상하기 어려운 점이 있다 (예를 들어 워드작업이 얼마나 걸릴지 예상하기 힘들다.)


<img width="478" alt="image" src="https://github.com/lenn-dev/TIL/assets/37726487/d76e18c2-76c6-459d-945e-eba6b4b1e686">


 
## SRT (Shortest Remaining Time)
- SJF 알고리즘을 선점형으로 변형한 알고리즘이다.
- 남은 실행시간이 짧다고 추정되는 프로세스를 먼저 디스패치하여 자원을 할당하는 CPU 스케줄링 알고리즘이다. 새로 도착하는 프로세스를 포함하여 계산한다.
- 실행 중인 프로세스가 있어도, 제일 잔여시간 짧은 프로세스가 있다면 진행중이 프로세스를sleep시킨 후, 짧은 프로세스를 먼저 할당한다.
- 0초 : 준비 큐에 있는 A가 CPU를 할당 받아 우선 실행된다.
- 2초 : B가 준비 큐에 도착했고, 남은 실행시간을 비교하면 A[2] < B[3] 이므로 A가 계속 실행된다.
- 4초 : A 프로세스 종료되고, 준비 큐에 있던 B가 실행된다.
- 5초 : C가 준비 큐에 도착했다. 남은 실행시간 비교하면 B[2] > C[1] 이므로 문맥교환이 일어나고 C가 CPU를 할당 받아 실행된다. B[2]는 준비 큐로 이동한다.
- 6초 : C의 실행이 종료되었고, D가 준비 큐에 도착했다. 프로세스들의 남은 실행시간 비교하면 B[2] < D[5] 이므로 B가 실행된다.
- 7초 : E가 준비 큐에 도착했다. B[1] < E[2] < D[5] 이므로 실행중인 B가 가장 짧으므로 그대로 실행되어 1초 후 종료된다.
- 8초 : B의 실행이 종료되었고, 준비 큐에 남아있는 프로세스 중 E[2] < D[5] 실행시간 짧은 E 가 실행된다.
- 10초 : 준비 큐에 남아있는 마지막 프로세스인 D가 실행된다.
- 대기시간은 각각 A: 0,  B: 1,  C: 0,  D: 4,  E: 1
- 반환시간은 각각 A: 4,  B: 3,  C: 3,  D: 9,  E: 3
- 평균대기시간은 (0+1+0+4+1)/5 = 1.2
- 평균반환시간은 (4+3+3+9+3)/5 = 3.8
- SRT알고리즘이 SJF 알고리즘보다 평균 대기시간이나 평균 반환시간을 더 줄일 수 있다.
- SRT알고리즘은 실행되는 각 프로세스의 실행시간을 추적해야 하기 때문에, 각 작업이 서비스 받은 시간이 기록되어야 한다. 선점을 위한 문맥교환이 더러 일어나므로  SJF 방식과 비교할 때 비교적 오버헤드가 크다는 단점이 있다.

