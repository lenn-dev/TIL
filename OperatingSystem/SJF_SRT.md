<img width="961" alt="Screenshot 2024-03-08 at 6 28 41 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e03eae73-961e-45cf-ada1-a4d39f5f55f6">

SJF (Shortest Job First)
* 준비큐에 들어와 있는 프로세스 중에 실행시간이 짧다고 추정되는 프로세스를 먼저 디스패치하여 자원할당하는 알고리즘이다.
* 비선점 방식의 알고리즘이기 때문에 일단 하나의 프로세스가 시작되면 종료될 때까지 방해할 수 없다.  
* 주어진 도착시간과 CPU 사이클 조건을 바탕으로 SJF 알고리즘으로 적용해 보자. 5개의 프로세스의 도착시간이 같다고 가정한다면 CPU사이클이 짧은 순서인 C E B A D 순으로 실행될 것이나, 주어진 조건은 도착시간이 다르다. 
* 0 초 : A 프로세스가 먼저 실행된다. 비선점 방식이기 때문에 A의 작업이 완료될 때까지 방해받지 않고 실행된 후 4초 후에 종료된다.
* 2 초 : B 프로세스 도착. 비선점 방식의 알고리즘이라 A 프로세스 종료 시까지 대기한다.
* 4 초 : A의 작업이 종료되었을 때 준비 큐에 대기하고 있는 B가 CPU를 할당받고 실행된다.
* 5 초 : C 도착해서 준비 큐에서 대기
* 6 초 : D 도착해서 준비 큐에서 대기
* 7 초 : E 도착해서 준비 큐에서 대기, B 프로세스 종료되었다. 준비 큐에 대기중인 작업 시간을 비교하면 C[1] < E[2] < D[5] 가장 짧은 작업인 C 를 실행시킨다.
* 8 초 : C 프로세스 종료되고, 그 다음 짧은 작업인 E 가 실행된다. 
* 10 초 : 준비 큐에 남아있는 마지막 프로세스인 D 가 CPU를 할당받고 실행된다.

* 대기시간은 각각 A:0, B:2, C:2, D:5, E:1
* 반환시간은 각각 A:4, B:5, C:3, D:9 E:2 
* 평균 대기시간은 (0+2+2+5+1)/5 = 2
* 평균 반환시간은 (4+5+3+9+2)/5 = 4.6


* SJF 는 FCFS 알고리즘에서의 호위효과 문제가 해결되었지만, 실행시간이 긴 프로세스의 경우 영원이 CPU를 할당받지 못하는 기아(Starvation)현상이 발생할 수 있다.
* 실행시간을 추적하지만 사실 이 작업이 예상하기 어려운 점이 있다 (예를들어 워드작업이 얼마나 걸릴지 예상하기 힘듦)
</br>
</br>
<img width="960" alt="Screenshot 2024-03-08 at 8 56 47 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a2cbfb17-5876-47f1-9a1d-3764c1b6b38e">


SRT (Shortest Remaining Time)
* SJF 알고리즘을 선점형으로 변형한 알고리즘이다. (SJF + RR)
* 새로 들어오는 프로세스를 포함하여 남은 실행시간이 짧다고 추정되는 프로세스를 먼저 디스패치하여 자원을 할당하는 CPU 스케줄링 알고리즘이다.
* 진행 중인 프로세스가 있어도, 최단 잔여시간인 프로세스를 위해 sleep시키고 짧은 프로세스를 먼저 할당한다.
* 0초 : 준비 큐에 있는 A가 CPU를 할당받아 우선 실행된다. 
* 2초 : B가 준비 큐에 도착했고, 남은 실행시간을 비교하면  A[2] < B[3] 이므로 A가 계속 실행된다.
* 4초 : A 프로세스 종료되고, 준비 큐에 있던 B가 실행된다.
* 5초 : C가 준비큐에 도착했다. 남은 실행시간 비교하면 B[2] > C[1] 이므로 문맥교환이 일어나고 C가 CPU를 할당받아 실행된다. B[2]는 준비큐로 이동한다.
* 6초 : C의 실행이 종료되었고, D가 준비큐에 도착했다. 남은 실행시간 비교하면 B[2] < D[5] 이므로 B가 실행된다.
* 7초 : E가 준비큐에 도착했다. B[1] < E[2] < D[5] 이므로 실행중인 B가 가장 짧으므로 그대로 실행되어 1초 후 종료된다.
* 8초 : B의 실행이 종료되었고, 준비큐에 남아있는 프로세스 중  E[2] < D[5] 실행시간 짧은 E 가 실행된다.
* 10초 : 준비 큐에 남아있는 마지막 프로세스인 D가 실행된다.

* 대기시간은 각각 A:0, B:1, C:0, D:4, E:1
* 반환시간은 각각 A:4, B:4, C:1, D:9, E:3
* 평균대기시간은 (0+1+0+4+1)/5 = 1.2
* 평균반환시간은 (4+4+1+9+3)/5 = 4.2


* SRT 가 SJF 보다 평균 대기시간이나 평균 반환시간에서 효율적이다.
* SRT는 실행되는 각 작업의 실행시간을 추적하여 각 프로세스가 서비스를 받은 시간이 기록되어야 하며, 때로는 선점을 위한 문맥교환 해야 하므로 SJF 보다 오버헤드가 더 크다.

