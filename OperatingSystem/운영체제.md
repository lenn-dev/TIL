<강의,교재,동영상 꼼꼼히 구조체,포인터,템플린 어려움>
중간과제물	온라인과제물	교재 1장～3장(해당 멀티미디어강의 1강～3강 포함)</br> 	              
형성평가	진도20 </br> 	 
기말시험	온라인출석시험(객관식)	교재4장~15장(해당 멀티미디어 강의 4강~15강 포함)   </br> 	  
### 목차
1. [운영체제 소개](#운영체제-소개)
2. [프로세스와 쓰레드](#프로세스와-쓰레드)
3. [프로세스 스케줄링](#프로세스-스케줄링)
4. [병행 프로세스 1](#병행-프로세스-1)
5. [병행 프로세스 2](#병행-프로세스-2)
6. [교착상태 1](#교착상태-1)
7. [교착상태 2](#교착상태-2)
8. [메모리 관리](#메모리-관리)
9. [가상 메모리](#가상-메모리)
10. [페이지 교체 알고리즘](#페이지-교체-알고리즘)
11. [장치관리](#장치관리)
12. [저장장치 및 파일관리](#저장장치-및-파일관리)
13. [분산 운영체제](#분산-운영체제)
14. [운영체제 보안](#운영체제-보안)
15. [운영체제 사례](#운영체제-사례)

# 운영체제 소개
#### 학습목표
- 운영체제의 개념과 역할을 설명할 수 있다.
- 운영체제의 구성을 설명할 수 있다.
- 운영체제의 유형을 설명할 수 있다.

## 1. 운영체제란 무엇인가?
  운영체제는 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌
  <img width="675" alt="Screenshot 2024-03-06 at 5 52 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d7ebdd9d-7e2a-45ed-8e1e-aef3f97bd6ef">


### 컴퓨터 시스템의 구성
  - __하드웨어__ : cpu,메모리,저장장치,입출력장치,네트워크 장치 등
  - __소프트웨어__ : 브라우저 pdf viewer, 프로그램언어
  - __운영체제__
      - 대표적인 시스템 소프트웨어 : Windows11, Mac OS, 컴파일러, Linux (응용소프트웨어와 하드웨서 사이에서 매개체역할)</br>
      - 하드웨어와 응용프로그램 사이에 운영체제 위치하여, 컴퓨터 시스템이 안정적이고 효율적으로 동작하도록 함
      - 컴퓨터 시스템의 자원(하드웨어/소프트웨어 자원,데이터)을 관리 :(예시) 저장장치의 데이터 읽어오기, 키보드/마우스제어, 프로그램 동시실행시 cpu/메모리 효율적 관리</br> 
      - 사용자 지원 : 사용자명령 해석/실행, 사용자와 하드웨어 사이 매개체 역할, 편의성 제공
  - __커널(kernel)이란?__
    - 컴퓨터 전원이 켜짐과 동시에 운영체제 중 항상 필요한 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려 사용. 이때 메모리에 상주하는 운영체제의 부분을 커널(kernel)이라고 하며 운영체제의 핵심적인 부분을 뜻한다.
    - __커널 구성방식__ :
      - __일체형커널__(운영체제 모든 서비스가 커널내 포함 UNIX,Linux): 커널 내부요소 상호작용,한 요소라도 오류발생시 시스템 전체장애
      - __마이크로커널__(운영체제 요소 대부분을 커널 외부로 분리): 유지보수용이, 안정적, 프로세스간 통신(IPC)필요해 성능저하
  - __CPU 모드__
    - __커널모드(수퍼바이저모드)__: 하드웨어 직접제어, 운영체제(OS)가 CPU를 사용하는 모드. `시스템 콜`을 통해 `커널모드`로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어를 실행한다.
    - __사용자모드(보호모드)__ : 사용자모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당모드에서는 하드웨어(디스크,I/O)등에 접근할 수 없다. 접근을 위해서 `시스템 콜(system call)` 을 사용해야 한다. 사용자 애플리케이션의 각 스레드는 고유의 사용자모드 스택을 갖는다.
<img width="689" alt="Screenshot 2024-03-06 at 6 00 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c65e5f45-804a-4b0d-accc-b39bfcf9520b">
    
위 그림같이 사용자 process 는 user mode에서 실행되다가 시스템 자원을 사용해야 할때 시스템 콜을 하여 커널모드로 전환한 뒤 작업을 수행하고 완료 후에 다시 사용자 모드로 전환한다.

  - __시스템호출__ : 응용프로그램이 하드웨어에 대한 제어가 필요한 경우 이용
    
  - C 언어를 프로그램을 통한 시스템 콜 이해
```
#include <stdio.h>
int main()
{
  ...
  printf("Hello World!");
  ...
  return 0;
}
```
`printf()` 함수는 `user mode`에서 수행되어 `stdio 라이브러리`를 호출한다. stdio 라이브러리는 `시스템 콜`인 `write()`를 호출하고, 실행의 흐름은 `kernel mode` 로 바뀐다. 커널은 호출을 실행하여 모니터에 문자열을 출력하고 실행의 흐름은 다시 user mode 로 넘어와 printf()의 함수의 다음단계를 진행한다.
<img width="578" alt="Screenshot 2024-03-06 at 6 22 12 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/42d75bb6-2b89-4d34-81f9-3ac1d4a130e9">


### 운영체제의 구성
  - 프로세스 관리자 : 프로세스 생성 및 삭제, CPU 할당을 위한 스케쥴 결정, 프로세스 상태관리하며 상태 전이처리
  - 메모리 관리자 : 메모리(주기억장치) 공간에 대한 요구의 유효성확인, 메모리할당 및 회수, 메모리 공간 보호
  - 파일 관리자 : 모든 파일관리, 저장장치 공간관리, 파일접근제한 관리
  - 장치 관리자 : 컴퓨터 시스템의 모든 장치(하드디스크,SSD,키보드,마우스,프린터,유무선네트워크카드)관리,

    
### 운영체제 유형
  - 일괄처리 운영체제 : Batch processing 작업을 모아 순차적으로 처리하는 방식
  - 시분할 운영체제 : (대화형운영체제) Time-sharing 각 사용자의 프로그램을 한 번에 조금씩 수행, 응답시간 단축
  - 실시간 운영체제 : Real-time 원하는 시간 내에 프로그램의 결과를 얻을 수 있는 방식, 증권관리시스템, 미사일제어시스템
  - 분산 운영체제 : 분산시스템 (2개 이상의 컴퓨터시스템이 네트워크로 서로 연결되어 서로 자원을 이용하는 시스템)을 관리하는 운영체제
    
---

# 프로세스와 쓰레드
## 프로세스
### 프로세스의 개요
- __프로세스(process)__: 실행 중인 프로그램의 인스턴스, 프로그램은 데이터 상태로 `보조기억장치`에 저장되어 있으며, 프로그램이 `실행`되면 `메모리`에 적재되어 `프로세스` 된다.
  - 프로그램: 동작하지 않는 정적,수동적 개체
  - 프로세스 :동작하는 능동적 개체
- 운영체제로부터 자원을 할당 받아 동작
    - 자원: CPU, 메모리, 입출력장치, 파일 등
    - 동작: CPU가 프로세스의 명령을 실행

#### 프로세스 종류
- __포그라운드 프로세스 (Foreground Process)__: 사용자와 상호작용하면서 실행되는 프로세스. 주로 사용자 인터페이스를 통해 입력을 받거나 출력을 제공하고, 명령을 처리, 작업을 수행한다. 사용자가 직접 보고 제어할 수 있으며, 사용자와의 상호작용을 위해 우선순위를 가지고 실행된다.
- __백그라운드 프로세스 (Background Process)__ : 사용자와 상호작용하지 않고 실행되는 프로세스. 주로 시스템 작업, 보조 작업 처리하는데 사용됨. 사용자의 입력,제어를 기다리지 않고 실행되기에 높은 우선순위 가짐. 일반적으로 백그라운드 프로세스는 시간이 오래 걸리는 작업이나 자동화된 작업을 처리하는데 사용됨

예시) 웹 브라우저 실행한다고 가정. 
웹 브라우저 자체는 포그라운드 프로세스로 실행되며, 사용자가 웹 페이지를 찾아보거나 입력하면 이를 처리함.웹 브라우저에서 파일을 다운로드하는 경우, 다운로드 작업은 백그라운드 프로세스로 실행됨. 사용자는 다운로드 작업이 백그라운드에서 진행되는 동안에도 브라우저를 계속 사용 가능함.
      
### 프로세스와 운영체제 
- 운영체제(프로세스 관리자)가 처리하는 작업
  - 프로세스를 생성 및 종료
  - 프로세스를 실행시키기 위한 스케줄링 작업
  - 프로세스의 상태 관리
    
### 프로세스의 구성 : 

- ### __메모리 구조__ : 프로그램 실행에 직접적으로 필요한 코드와 데이터 (커널영역, 사용자영역으로 나뉨)
- 사용자 영역에서 프로세스는 코드, 데이터, 힙, 스택 영역으로 나뉨
<img width="222" alt="Screenshot 2024-03-06 at 9 54 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4f2d3be8-f5e2-462f-ad9a-e5ab8e990e8a">

- __커널 영역__ : PCB 가 저장됨
- __코드 영역__ : 실행하는 프로그램 코드가 기계어로 저장되며 `텍스트 영역`이라고도 함. 데이터 저장이 아닌, CPU가 실행할 `명령어`가 저장되어 있어서 쓰기가 금지된 `read-only` 영역임. CPU는 코드 영역에 저장된 명령어를 하나씩 처리함
- __데이터 영역__ : 프로그램 실행 중에 유지할 데이터 저장. 프로그램 가상 주소 공간, `전역변수`, `정적변수` 저장하고 실행될 때 할당되고, 프로그램 종료되면 소멸. 
- __힙 영역__ : 사용자가 직접 관리 가능한 메모리 영역으로,`런 타임`에 할당받을 메모리 크기가 결정됨. 코드영역과 별도로 유지되는 자유영역, C 계열의 `malloc()`과 java 계열의 `new()` 명령어 통해 인스턴스 생성하면, `동적`으로 힙 영역 메모리 할당받아 데이터가 저장됨. 
힙 영역은 사용자가 직접 `메모리를 반환`해야 하며, 반환하지 않으면 지속적으로 메모리 공간을 차지하는 `메모리 누수 (Memory Leak)` 현상 발생함. C 언어에서는 `free` 함수를 통해 메모리를 반환하며, 자바에선 `가비지 콜렉션(Garbage Collection)`에 의해 자동으로 메모리가 반환됨.
- __스택 영역__ : 함수 호출 시 생성되는 `지역변수`, `매개변수` 등의 데이터가 일시적으로 저장되는 영역으로 `컴파일 타임`에 할당받을 메모리 크기가 결정됨. 함수를 호출하면 `동적`으로 스택 영역을 할당받아 데이터가 저장되고, 함수 호출이 완료되면 할당받은 메모리를 반환한다. 힙과 인접한 방향으로 점점 커져 스택 포인터와 힙 포인터가 만나면 메모리가 소진되었다는 의미
`푸시(push)` 동작으로 데이터를 저장하고, `팝(pop)`동작으로 데이터를 인출함. 데이터 인출시 `후입선출(Last-In-First-Out,LIFO)` 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 먼저 인출된다.

- __정적 할당 영역__ : 코드영역과 데이터 영역은 프로그램 시작시 고정적으로 메모리 할당 받음
- __동적 할당 영역__ : 힙 영역과 스택 영역은 메모리를 동적으로 할당 받음. 힙 영역 ( 낮은 주소에서 높은 주소 방향으로 메모리 할당), 스택 영역 ( 높은 주소에서 낮은 주소 방향으로 메모리가 할당)

- 만약 두 영역이 겹쳐 할당받을 메모리가 없게 되면 서로의 영영을 침범할 수 있음. 이 때 스택이 힙 영역을 침범하는 경우를 `스택 오버플로우(Stack Overflow)`, 힙이 스택 영역을 침범하는 경우를 `힙 오버플로우(Heap Overflow)`라고 함.



- ### __프로세스 제어 블록 (PCB :Process Control Block)__
  - 특정 프로세스를 관리할 때 필요한 정보를 포함하는 운영체제 커널의 자료구조.
  - CPU는 한정된 자원을 가지기 때문에 각 프로세스는 돌아가면서 한정된 시간만큼 CPU를 사용하고, 타이머 인터럽트가 발생하면 다음 프로세스에게 차례를 양보한다.
  - 운영체제는 빠르게 번갈아 실행되는 이런 프로세스들을 스케줄링, 제어할 필요가 있는데 이 때 각 프로세스 고유의 PCB에 저장된 정보를 사용한다.
  - `커널 영역`에 각 프로세스에 대한 `PCB 를 생성`하고 프로세스의 `상태 및 관련정보를 추적`하며, 프로세스 완료 후 `제거`된다.
 
  - 프로세스가 CPU를 점유하여 작업처리하다가, 프로세스 `상태 전이`가 일어나면 CPU를 반환해야 하는데, 이때 진행중이던 작업을 PCB에 저장했다가, 다시 프로세싱 순서가 돌아오면, PCB 로부터 해당 정보를 CPU에 넘겨와 작업을 계속할 수 있다.</br>
    <img width="230" alt="Screenshot 2024-03-06 at 3 42 10 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/973e7726-49cd-4210-9f53-138bcede3175">
  - `PID (Process ID)`:  프로세스 식별자
  - `프로세스 상태` : 생성, 준비, 실행, 대기, 완료
  - `PC (Program Counter)`: 현재 실행 중인 프로그램 명령어의 주소를 가리키는 레지스터 값. 프로세스는 다음에 실행할 명령어를 PC의 값에 따라 결정한다. 
  - `레지스터 값` : 프로세스가 현재 사용중인 레지스터 값을 저장하여 프로세스가 실행되는 동안 레지스터 값 유지되도록 한다.
  - `메모리 관리정보` : 프로세스가 사용하는 메모리 주소범위, 페이지 테이블 정보같은 메모리관리에 필요한 정보를 포함. 
  - `스케줄링 정보` (프로세스 우선순위) CPU 점유시간, 대기시간 등 스케줄링과 관련된 정보 포함. 운영체제는 이 정보를 기반으로 프로세스 스케줄링 알고리즘을 실행해 어떤 프로세스를 실행시킬지 결정.
  - `입출력 상태 정보` : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등
  - `회계정보`
  - `프로세스 계정정보` : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
  - `포인터` : 부모 프로세스에 대한 포인터, 자식 프로세서에 대한 포인터, 프로세서가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등


### 프로세스 상태관리
#### 프로세스 상태 변화 : 생성(New), 준비(Ready), 실행(Run), 대기(Wait),종료(Exit)
<img width="552" alt="Screenshot 2024-03-06 at 9 41 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1231662f-7c57-4a87-be02-f4d8888d8819">


- __준비 -> 실행__ : 준비 큐 앞에 있던 프로세스가 프로세스를 점유, 표기법: Dispatch(프로세스 이름)
- __실행 -> 준비__ : 프로세스가 프로세서를 독점하지 못하도록 인터럽트 클락(interruptClock) 을 두어 할당된 시간동안만 프로세서를 점유 표기법: Timeout(프로세스 이름)
- __실행 -> 대기(보류)__ : 할당된 시간 이전에 실행상태의 프로세스에 입출력 연산 등이 필요하거나 새로운 자원요청의 문제로 프로세서를 스스로 양도하는 상태, 표기법: block(프로세스이름)
- __대기(보류) -> 준비__ : block 상태의 프로세스가 입출력 작업이 끝나면 대기에서 준비상태가 된다, 표기법: wakeup(프로세스 이름)

### 부모 프로세스와 자식 프로세스
#### 프로세스 생성방법
- 사용자가 프로그램을 직접 실행
- 한 프로세스가 다른 프로세스를 생성
    - 프로세스 생성 __시스템 호출__ 이용
    - 부모 프로세스: 시스템 호출을 하는 프로세스
    - 자식 프로세스: 시스템 호출을 통해 새로 생성된 프로세스

### 프로세스 생성 : 시스템 호출 (시스템 콜)
:fork, wait, exec, dup, dup2, pipe...

#### UNIX, Linux : fork()
- 자식 프로세스는 부모 프로세스의 복제본
  <img width="587" alt="Screenshot 2024-03-06 at 4 11 28 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4631da03-b550-4a15-bb90-f16cc3ec745a">

프로세스는 프로그램을 실행 시 생성된다. 이때 운영체제가 프로그램 코드를 메모리의 `코드영역`에 할당하고 PCB를 생성한 후 메모리의 `데이터영역`, `스택영역`을 확보하여 프로세스를 실행한다. </br>
`유닉스 계열`의 운영체제의 경우 새로운 프로세스를 생성할 때 위 과정을 모두 거치지 않고, `fork` 시스템 호출을 통해 기존 프로세스를 복사하여 새로운 프로세스를 생성한다. 이때 fork 시스템 호출하는 프로세스는 부모 프로세스, 새로 만들어진 프로세스는 자식 프로세스가 되어 계층 구조를 형성함.</br>
fork 를 호출하면 PCB 를 포함한 부모 프로세스 대부분이 자식 프로세스에 복사되어 동일한 프로세스 생성됨. 다만 `PID`, `PPID`, `CPID` 등 일부 데이터가 수정됨. PPID는 부모프로세스의 PID, CPID 는 자식프로세스의 PID 이다.</br>

<img width="337" alt="Screenshot 2024-03-06 at 10 45 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/28f94312-b828-4e39-b722-6bbb937d817d">

C언어 fork 예제코드 
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void main() {

  pid_t pid;

  printf("first_PID: %ld\n", (long)getpid());
  printf("first_PPID: %ld\n", (long)getppid());
  printf("---------------------\n");

  pid = fork();

  while(1) {

    if(pid < 0) {
      printf("Error");
      exit(-1);
    }
    else if(pid == 0) {
      printf("Child Process!\n");
    }
    else {
      printf("Parent Process!\n");
    }

    printf("PID: %ld\n", (long)getpid());
    printf("PPID: %ld\n", (long)getppid());
    printf("saved PID: %ld\n", (long)pid);
    printf("---------------------\n");

    sleep(1);
  }
}
```

<img width="324" alt="Screenshot 2024-03-06 at 10 54 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/2963a502-cc86-4482-9602-785332f0d46e">

실행 결과를 살펴보면 `first_PID`와 `first_PPID`가 부모 프로세스의 `PID`, `PPID`와 동일하다는 것을 볼 수 있다. 부모 프로세스와 자식 프로세스가 동기화되어 실행되는 것처럼 보이지만 실제로는 독립적으로 실행되고 있다.
fork 시스템 호출을 요청하면 부모 프로세스에는 `자식 프로세스의 PID`를 리턴하고, 자식 프로세스에는 `0`을 리턴합니다. 또한 자식 프로세스는 부모 프로세스의 PCB를 상속받았기 때문에 `프로그램 카운터(PC)가 동일`하여 fork 시스템 호출을 요청한 이후의 코드가 실행됩니다. 그렇기 때문에 _자식 프로세스에서는 first_PID와 first_PPID를 출력하지 않습니다._


#### UNIX, Linux : exec()
- 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행
  <img width="587" alt="Screenshot 2024-03-06 at 4 12 46 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/97861f97-f923-4eb5-8d48-046051fcb22a">


자식 프로세스에서 새로운 프로그램을 실행하려면  `exec` 시스템 호출을 요청하면 된다. exec 시스템 호출을 요청하면 자식 프로세스의 코드 영역을 새로운 코드로 교체하고 PCB에서 프로그램 카운터나 각종 레지스터, 파일 정보 등이 리셋된다.
<img width="503" alt="Screenshot 2024-03-06 at 11 09 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0cf76854-faad-46da-b920-eb51aafdb37b">

exec 예제코드: parent C
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void main() {

  pid_t cpid;

  printf("parent process!!\n");

  cpid = fork();

  if(cpid == 0) {
    execl("./child", "./child", NULL);
    printf("child process failed to exec\n");
    exit(0);
  }

  wait(NULL);
  exit(0);
}
```
exec 예제 코드: child
```
#include <stdio.h>
#include <stdlib.h>

void main() {
  printf("child process!!\n");
  exit(0);
}
```
 <img width="326" alt="Screenshot 2024-03-06 at 11 11 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a42e9a3c-cf0a-47d9-a40d-2aa1f30c9c9c">

부모 프로세스가 먼저 종료되면 자식 프로세스도 종료되기 때문에 parent 코드에서 wait 함수를 통해 자식 프로세스와 동기화 시킨다.

parent를 실행하면 fork 시스템 호출에 의해 자식 프로세스가 생성되고, exec 시스템 호출에 의해 자식 프로세스는 child를 실행한다. 코드 영역이 child 코드로 변경되었기 때문에 “child process failed to exec” 라는 메시지는 출력되지 않는다.

fork와 exec를 통해 프로세스를 생성하는 방식은 프로세스 생성 과정 전체를 거치지 않기 때문에 프로세스 생성 속도가 빠르고 추가 작업 없이 자원의 상속이 가능하여 시스템 관리에 효율적.
  
#### Windows : CreateProcess()
- 자식 프로세스는 새로운 프로그램으로 생성
  <img width="585" alt="Screenshot 2024-03-06 at 4 14 04 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/047b338b-3b00-4bd6-8b63-6b57b7f36d24">
  
#### 부모 프로세스와 자식 프로세스
- 프로세스 종료 방법
  - 프로세스가 모든 처리를 완료(정상적 종료)
  - 부모 프로세스에 의해 자식 프로세스가 강제 종료
      - 프로세스 종료 __시스템 호출__ 이용
      - 자식 프로세스 생성시 얻은 자식 PID 이용
  - 부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료

### 전통적인 프로세스
- 하나의 프로그램을 실행하기 위한 기본적인 단위
- 자원 소유 단위 (하나의 메모리 구조)
- 디스패칭의 단위 (하나의 제어흐름)
- 프로세스 내에서 다중처리 불가능

## 쓰레드
### 전통적인 프로세스
### 쓰레드 (thread)
### 프로세스 비교
### 쓰레드와 프로세스
### 다중 쓰레드로 구성된 프로세스

[참고](https://didu-story.tistory.com/311)
[참고](https://huimang2.github.io/etc/computer-process.html)


# 프로세스 스케줄링
CPU 스케줄링 (CPU Scheduling) 이란 운영체제가 프로세스에 합리적으로 CPU 자원을 할당하는 정책을 만드는 것을 말한다. 멀티태스킹을 위해 운영체제가 CPU의 가동시간을 적절히 나누어 프로세스에게 사용시간을 분배한다. 이때 시스템과 사용자의 입장에서 CPU 성능에 대한 척도가 달라진다.

#### 1. 시스템 입장에서의 성능 척도
- CPU 사용률(CPU Utilization) : 전체 시스템 시간 중 CPU 가 작업을 처리하는 시간의 비율
- 처리량 (Throughtput) : CPU 가 단위 시간당 처리하는 프로세스 개수
#### 2. 사용자 입장에서의 성능 척도
- 대기시간(Waiting Time) : 프로세스가 준비 상태에서 CPU를 할당 받을 때까지 대기한 시간
- 응답시간(Response Time) : 프로세스의 명령 요청 후 응답이 올 때까지의 시간
- 반환시간(Turnaround Time): 프로세스가 시작해서 끝날 때까지 걸리는 시간

시스템 입장에서는 CPU를 쉬지않고 최대한 많이 가동시키는 것이 중요하고, 사용자 입장에서는 요청한 작업이 빨리 처리되는 것이 중요하므로 운영체제는 상황에 맞게 CPU 스케줄링을 설계할 필요가 있다.
DPU 스케줄링은 스케줄링 방식에 따라 `선점형`과 `비선점형`으로 나뉜다.

`선점(preemptive)`이란 빼앗을 수 있음을 의미한다. 즉 선점형 스케줄링은 운영체제가 필요하다고 판단할 경우 실행중인 프로세스를 중단하고, 다른 프로세스에게 CPU 자원을 할당하여 실행할 수 있다.</br>
반면 `비선점` 스케줄링은 프로세스에게 할당된 CPU를 강제로 빼앗을 수 없고, 프로세스의 사용이 끝난 후에야 다른 프로세스에게 CPU 자원 할당이 가능하다. 

선점형 스케줄링 경우 하나의 프로세스가 자원 독점하지 못하게 막을 수도 있지만, `문맥교환` 과에서 `오버헤드`가 발생할 수 있다. 반면 비선점형 스케줄링의 경우 문맥교환에 대한 오버헤드가 없지만, 전체 시스템 처리율이 떨어질 수 있다.

운영체제는 PCB를 `스케줄링 큐(Queue)`에서 리스트 형태로 관리한다. 보통 `큐`는 `선입선출 방식`을 따르는 자료구조이지만, `스케줄링 큐`는 스케줄링 알고리즘에 따라 다른 자료구조를 가질 수 있다. 스케줄링 큐는 프로세스 `상태`에 따라 `준비 큐(Ready Queue)`, `대기 큐(Waiting Queue)` 등 여러 큐가 존재한다. 

## 스케줄링 성능 평가 기준
### 1. 평균 대기시간 (Average waiting time)
- 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값
### 2. 평균 반환시간 (Average trunaround time)
- 각 프로세스가 생성된 시점 ( 여기서는 준비 큐에 들어온 시점과 동일한 것으로 가정) 부터 수행이 완료된 시점까지의 소요시간의 평균값
  
## 비선점형 스케줄링
### 1. 선입 선처리 (FCFS, First Come First Served) 알고리즘
- 프로세스는 준비 큐에서 도착순서에 따라 디스패치되며, 일단 한 프로세스가 CPU를 차지하면, 그 프로세스의 수행이 완료된 후에 그 다음 프로세스가 CPU를 차지하고 수행된다.
- 공정해 보이나, 짧은 작업이 긴 작업을 기다리게 되거나,중요 프로세스가 나중에 수행될 수 있는 불합리함이 있어 대화식 시스템에 부적합하다. 프로세스들의 __도착순서__ 에 따라 __평균반환시간이 크게 변한다.__
- 직관적이고 단순한 알고리즘이지만 평균 대기시간이 길어지는 `호위 효과(Convoy Effect)` 문제가 있다.
<img width="672" alt="Screenshot 2024-03-07 at 2 52 06 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/8d5d3800-6fed-49dc-b592-0f056252ce39"></br>
- P<sub>1</sub> 은 20초, P<sub>2</sub> 은 3초, P<sub>3</sub> 은 7초, P<sub>4</sub> 은 5초의 실행시간이 걸린다. 
- 도착시간이 0 초로 모두 동일하다 가정하면 __P<sub>1</sub> -> P<sub>2</sub> -> P<sub>3</sub> -> P<sub>4</sub>__ 순서로 실행됨
- P<sub>1</sub> 은 0초, P<sub>2</sub> 은 20초, P<sub>3</sub> 은 23초, P<sub>4</sub> 은 30초의 대기시간을 가지게 되어 평균 대기시간은 __18.25초__ 가 된다.
- (0 + 20 + 23 + 30) / 4 = 18.25

  
### 2. 최단 작업 우선 (SJF, Shortest Job First) 알고리즘
- FCFS 알고리즘을 보완하여 __실행시간이 짧다__ 고 추정되는 프로세스를 먼저 디스패치하여 자원할당하는 알고리즘이다.
- 일괄처리 환경에서 구현이 쉽고, 알고리즘으로 실행할 프로세스의 CPU 소요시간이 미리 주어진다.
- 위 FDFS 의 예시를 SJF 알고리즘으로 적용해 보면, 실행시간이 가장 짧은 작업부터 처리하여, __P<sub>2</sub> -> P<sub>4</sub> -> P<sub>3</sub> -> P<sub>1</sub>__ 순서대로 실행된다.
- P<sub>2</sub> 은 0초, P<sub>4</sub> 은 3초, P<sub>3</sub> 은 8초, P<sub>1</sub> 은 15초의 대기시간을 가지게 되어 평균 대기시간은 __6.5초__ 가 된다.
- (0 + 3 + 8 + 15) / 4 = 6.5
- 짧은 작업이라도 이미 CPU가 선점되어 있다면, 비선점 방식이기 때문에 우선 실행되는 프로세스가 종료될때까지 기다릴 수 밖에 없다. 
- SJF 는 FCFS 알고리즘에서의 호위효과 문제가 해결되었지만, 실행시간이 긴 프로세스의 경우 영원이 CPU를 할당받지 못하는 기아(Starvation)현상이 발생할 수 있다.
- 실행시간을 추적하지만 사실 이 작업이 예상하기 어려운 점이 있다 (예를들어 워드작업이 얼마나 걸릴지 예상하기 힘듦) 

  
### 3. 최고 응답률 우선(HRN, Hightest Response-ratio Next) 알고리즘
- 점유의 불평등 현상이 발생하는 SJF 알고리즘을 보완하여 응답률이 높은 프로세스에게 먼저 자원을 할당하는 CPU 알고리즘이며, 다음 계산식을 통해 프로세스의 우선순위를 결정한다.
- 우선순위 = (대기시간 + 실행시간) / 실행시간 
- P<sub>2</sub> 가 처음 실행되었다고 가정하면 프로세스 순위계산은 다음과 같다.
- P<sub>1</sub> :(3 + 20 ) / 20 = 1.15
- P<sub>3</sub> : (23 + 7 ) / 7 = 4.3
- P<sub>4</sub> : (30 + 5 ) / 5 = 7
- 대기 시간이 길어질 수록 값이 커져서 우선순위가 높아지고, P<sub>4</sub>의 기아현상도 해소된다.
- 따라서 P<sub>2</sub> 실행 이후 __P<sub>4</sub> -> P<sub>3</sub> -> P<sub>1</sub>__ 순서대로 프로세스가 실행된다.

## 선점형 스케줄링
### 1. 라운드 로빈(RR, Round Robin) 알고리즘
- RR 알고리즘은 FCFS 알고리즘을 선점형으로 변형한 알고리즘이다. 선점형 스케줄링의 경우 정해진 시간만큼 프로세스가 돌아가면서 CPU를 사용하며, 해당 시간을 초과하면 `타임 아웃 인터럽트(Time out Interrunpt)`에 의해 CPU 점유를 뺏기고 `준비 큐`의 맨 뒤로 들어간다.</br>
- 이 `시간할당량`을 `타임 슬라이스(Time Slice)` 라고 하며, 선점형 스케줄링에선 타임 슬라이스의 `크기`가 중요하다. 타임 슬라이스가 너무 크면 비선점형과 다를바 없어 호위효과 문제가 발생할 수 있으며, 너무 작으면 잦은 문맥교환으로 인한 오버헤드가 발생해 CPU 성능이 떨어질 수 있다.
- CPU를 독점하지 않고, 공평하게 이용하며, 시분할 운영체제에 적합하다. 
  
  
<img width="647" alt="Screenshot 2024-03-07 at 3 52 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/78a692f4-68de-466f-9368-e94ba15a5b45">

- 도착시간이 0초로 모두 동일하고 타임 슬라이스는 5초라고 가정하면, P<sub>1</sub>(실행시간:20초)과 P<sub>3</sub>(실행시간:7초)은 타임슬라이스를 5초를 초과하여 문맥 교환이 발생한다. 그러므로 P<sub>1</sub> → (문맥교환) → P<sub>2</sub> → P<sub>3</sub> → (문맥교환) → P<sub>4</sub> → P<sub>1</sub> → (문맥교환) → P<sub>3</sub> → P<sub>1</sub> 순서로 실행됩니다.


### 2. 최소 잔여 시간 우선(SRT, Sortest Remaining Time)
- SJF 알고리즘을 선점형으로 변형한 알고리즘이다. (SJF + RR)
- 새로 들어오는 프로세스를 포함하여 남은 실행시간이 짧다고 추정되는(이 부분을 예상하기란 쉽지 않음) 프로세스를 먼저 디스패치하여 자원을 할당하는 CPU 스케줄링 알고리즘이다.
- SRT 가 SJF 보다 평균 대기시간이나 평균 반환시간에서 효율적이다.
- SRT는 실행되는 각 작업의 실행시간을 추적하여 각 프로세스가 서비스를 받은 시간이 기록되어야 하며, 때로는 선점을 위한 __문맥교환__ 해야 하므로 __SJF 보다 오버헤드가 더 크다.__
  
<img width="651" alt="Screenshot 2024-03-07 at 4 04 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/2c0ded31-8399-4e46-8b98-7ec88ecde84d"></br>

- 도착시간이 0초로 모두 동일하고 타임 슬라이스는 5초라고 가정하면 실행시간이 3초로 가장 짧은 P<sub>2</sub> 실행으로 시작해 P<sub>2</sub> → P<sub>4</sub> → P<sub>3</sub> → (문맥교환) → P<sub>1</sub> → (문맥교환) → P<sub>3</sub> → P<sub>1</sub> 순서로 실행된다.

### 3. 다단계 큐(MQ, Multi-level Queue) 알고리즘
- MQ 알고리즘은 프로세스의 특성별로 준비 큐를 여러 개 두어 우선순위를 부여하고, 높은 우선순위에 있는 프로세스에게 먼저 자원을 할당하는 알고리즘이다.

<img width="661" alt="Screenshot 2024-03-07 at 4 14 10 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/66587112-ace8-4dcf-b1ae-ab91894cfbf6">

- 이 알고리즘은 특성별 큐 별로 서로 다른 CPU 스케줄 알고리즘을 적용할 수 있지만, 프로세스가 큐 간의 이동이 불가능하기 때문에, 우선순위가 낮은 큐에 있는 프로세스들은 기아 현상이 발생할 수 있다. 

### 4. 다단계 피드백 큐(MFQ, Multi-level Feedback Queue) 알고리즘
- MQ 알고리즘의 발전된 형태로, 프로세스가 큐 간의 이동이 가능하다.
- MQ 알고리즘의 경우, 정해진 시간동안 작업을 처리하지 못하면 동일한 우선순위의 준비 큐에 들어가지만, 
- MFQ 알고리즘의 경우, 우선순위가 낮은 큐에 들어감으로써 프로세스 기아 현상을 해결할 수 있다. 이 기법을 에이징(aging)이라고 한다.

[참고](https://huimang2.github.io/etc/computer-scheduling)
[참고](https://hyuntaekhong.github.io/blog/OperatingSystem03/)
