<강의,교재,동영상 꼼꼼히 구조체,포인터,템플린 어려움>
중간과제물	온라인과제물	교재 1장～3장(해당 멀티미디어강의 1강～3강 포함)</br> 	              
형성평가	진도20 </br> 	 
기말시험	온라인출석시험(객관식)	교재4장~15장(해당 멀티미디어 강의 4강~15강 포함)   </br> 	  
### 목차
1. [운영체제 소개](#운영체제-소개)
2. [프로세스와 쓰레드](#프로세스와-쓰레드)
3. [프로세스 스케줄링](#프로세스-스케줄링)
4. [병행 프로세스 1](#병행-프로세스-1)
5. [병행 프로세스 2](#병행-프로세스-2)
6. [교착상태 1](#교착상태-1)
7. [교착상태 2](#교착상태-2)
8. [메모리 관리](#메모리-관리)
9. [가상 메모리](#가상-메모리)
10. [페이지 교체 알고리즘](#페이지-교체-알고리즘)
11. [장치관리](#장치관리)
12. [저장장치 및 파일관리](#저장장치-및-파일관리)
13. [분산 운영체제](#분산-운영체제)
14. [운영체제 보안](#운영체제-보안)
15. [운영체제 사례](#운영체제-사례)

# 운영체제 소개
#### 학습목표
- 운영체제의 개념과 역할을 설명할 수 있다.
- 운영체제의 구성을 설명할 수 있다.
- 운영체제의 유형을 설명할 수 있다.

  ### 1. 운영체제란 무엇인가?
  운영체제는 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌
  <img width="675" alt="Screenshot 2024-03-06 at 5 52 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d7ebdd9d-7e2a-45ed-8e1e-aef3f97bd6ef">


  #### 컴퓨터 시스템의 구성
  - 하드웨어 : cpu,메모리,저장장치,입출력장치,네트워크 장치 등
  - 소프트웨어 : 브라우저 pdf viewer, 프로그램언어
  - 운영체제
      - 대표적인 시스템 소프트웨어 : Windows11, Mac OS, 컴파일러, Linux (응용소프트웨어와 하드웨서 사이에서 매개체역할)</br>
      - 하드웨어와 응용프로그램 사이에 운영체제 위치하여 컴퓨터 시스템이 안정적이고 효율적으로 동작하도록 함
      - 컴퓨터 시스템의 자원(하드웨어/소프트웨어 자원,데이터)을 관리 :(예시) 저장장치의 데이터 읽어오기, 키보드/마우스제어, 프로그램 동시실행시 cpu/메모리 효율적 관리</br> 
      - 사용자 지원 : 사용자명령 해석/실행, 사용자와 하드웨어 사이 매개체 역할, 편의성 제공
  - 커널(kernel)이란?
    - 컴퓨터 전원이 켜짐과 동시에 운영체제 중 항상 필요한 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려 사용. 이때 메모리에 상주하는 운영체제의 부분을 커널(kernel)이라고 하며 운영체제의 핵심적인 부분을 뜻한다.
    - 커널 구성방식 :
      - 일체형커널(운영체제 모든 서비스가 커널내 포함 UNIX,Linux): 커널 내부요소 상호작용,한 요소라도 오류발생시 시스템 전체장애
      - 마이크로커널(운영체제 요소 대부분을 커널 외부로 분리): 유지보수용이, 안정적, 프로세스간 통신(IPC)필요해 성능저하
  - CPU 모드
    - __커널모드(수퍼바이저모드)__:하드웨어 직접제어,운영체제(OS)가 CPU를 사용하는 모드. `시스템 콜`을 통해 `커널모드`로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어를 실행한다.
    - __사용자모드(보호모드)__ : 사용자모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당모드에서는 하드웨어(디스크,I/O)등에 접근할 수 없다. 접근을 위해서 `시스템 콜(system call)` 을 사용해야 한다. 사용자 애플리케이션의 각 스레드는 고유의 사용자 모드 스택을 갖는다.
<img width="689" alt="Screenshot 2024-03-06 at 6 00 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c65e5f45-804a-4b0d-accc-b39bfcf9520b">
    
위 그림같이 사용자 process 는 user mode에서 실행되다가 시스템 자원을 사용해야 할때 시스템 콜을 하여 커널모드로 전환한 뒤 작업을 수행하고 완료 후에 다시 사용자 모드로 전환한다.

- 시스템호출 : 응용프로그램이 하드웨어에 대한 제어가 필요한 경우 이용
- C 언어를 프로그램을 통한 시스템콜 이해
```
#include <stdio.h>
int main()
{
  ...
  printf("Hello World!");
  ...
  return 0;
}
```
printf() 함수는 user mode에서 수행되어 stdio 라이브러리를 호출한다. stdio 라이브러리는 시스템 콜인 write()를 호출하고, 실행의 흐름은 kernel mode 로 바뀐다. 커널은 호출을 실행하여 모니터에 문자열을 출력하고 실행의 흐름은 다시 user mode 로 넘어와 printf()의 함수의 다음단계를 진행한다.
<img width="578" alt="Screenshot 2024-03-06 at 6 22 12 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/42d75bb6-2b89-4d34-81f9-3ac1d4a130e9">


#### 운영체제의 구성
  - 프로세스 관리자: 프로세스 생성 및 삭제, CPU 할당을 위한 스케쥴 결정, 프로세스 상태관리하며 상태 전이처리
  - 메모리 관리자 : 메모리(주기억장치) 공간에 대한 요구의 유효성확인, 메모리할당 및 회수, 메모리 공간 보호
  - 파일 관리자 : 모든 파일관리, 저장장치 공간관리, 파일접근제한 관리
  - 장치 관리자 : 컴퓨터 시스템의 모든 장치(하드디스크,SSD,키보드,마우스,프린터,유무선네트워크카드)관리,

    
#### 운영체제 유형
  - 일괄처리 운영체제 :Batch processing 작업을 모아 순차적으로 처리하는 방식
  - 시분할 운영체제 : (대화형운영체제) Trime-sharing 각 사용자의 프로그램을 한 번에 조금씩 수행, 응답시간 단축
  - 실시간 운영체제 : Real-time 원하는 시간 내에 프로그램의 결과를 얻을 수 있는 방식, 증권관리시스템, 미사일제어시스템
  - 분산 운영체제 : 분산시스템(2개 이상의 컴퓨터시스템이 네트워크로 서로 연결되어 서로 자원을 이용하는 시스템)을 관리하는 운영체제
    
---

# 프로세스와 쓰레드
## 프로세스
### 프로세스의 개요
- 프로세스(process): 실행 중인 프로그램의 인스턴스, 프로그램은 데이터 상태로 보조기억장치에 저장되어 있으며, 프로그램이 실행되면 메모리에 적재되어 프로세스 된다.
  - 프로그램: 동작하지 않는 정적,수동적 개체
  - 프로세스 :__동작__ 하는 능동적 개체
- 운영체제로부터 자원을 할당 받아 __동작__
    - 자원: CPU, 메모리, 입출력장치, 파일 등
    - 동작: CPU가 프로세스의 명령을 실행

#### 프로세스 종류
- __포그라운드 프로세스 (Foreground Process)__: 사용자와 상호작용하면서 실행되는 프로세스. 주로 사용자 인터페이스를 통해 입력을 받거나 출력을 제공하고, 명령을 처리, 작업을 수행한다. 사용자가 직접 보고 제어할 수 있으며, 사용자와의 상호작용을 위해 우선순위를 가지고 실행된다.
- __백그라운드 프로세스 (Background Process)__ : 사용자와 상호작용하지 않고 실행되는 프로세스. 주로 시스템 작업, 보조 작업 처리하는데 사용됨. 사용자의 입력,제어를 기다리지 않고 실행되기에 높은 우선순위 가짐. 일반적으로 백그라운드 프로세스는 시간이 오래 걸리는 작업이나 자동화된 작업을 처리하는데 사용됨

예시) 웹 브라우저 실행한다고 가정. 
웹 브라우저 자체는 포그라운드 프로세스로 실행되며, 사용자가 웹 페이지를 찾아보거나 입력하면 이를 처리함.웹 브라우저에서 파일을 다운로드하는 경우, 다운로드 작업은 백그라운드 프로세스로 실행됨. 사용자는 다운로드 작업이 백그라운드에서 진행되는 동안에도 브라우저를 계속 사용 가능함.
      
### 프로세스와 운영체제 
- 운영체제(프로세스 관리자)가 처리하는 작업
  - 프로세스를 생성 및 종료
  - 프로세스를 실행시키기 위한 스케줄링 작업
  - 프로세스의 상태 관리
    
### 프로세스의 구성 : 

- __메모리 구조__ : 프로그램 실행에 직접적으로 필요한 코드와 데이터 (커널영역, 사용자영역으로 나뉨)
- 사용자 영역에서 프로세스는 코드, 데이터, 힙, 스택 영역으로 나뉨
<img width="222" alt="Screenshot 2024-03-06 at 9 54 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4f2d3be8-f5e2-462f-ad9a-e5ab8e990e8a">

- `커널 영역` : PCB 가 저장됨
- `코드 영역` : 실행하는 프로그램 코드가 기계어로 저장되며 `텍스트 영역`이라고도 함. 데이터 저장이 아닌, CPU가 실행할 `명령어`가 저장되어 있어서 쓰기가 금지된 `read-only` 영역임. CPU는 코드 영역에 저장된 명령어를 하나씩 처리함
- `데이터` : 프로그램 실행 중에 유지할 데이터 저장. 프로그램 가상 주소 공간, `전역변수`, `정적변수` 저장하고 실행될 때 할당되고, 프로그램 종료되면 소멸. 
- `힙 영역` : 사용자가 직접 관리 가능한 메모리 영역으로, `런 타임`에 할당받을 메모리 크기가 결정됨. 코드영역과 별도로 유지되는 자유영역, C 계열의 `malloc()`과 java 계열의 `new()` 명령어 통해 인스턴스 생성하면, `동적`으로 힙 영역 메모리 할당받아 데이터가 저장됨. 
힙 영역은 사용자가 직접 메모리를 반환해야 하며, 반환하지 않으면 지속적으로 메모리 공간을 차지하는 `메모리 누수 (Memory Leak)` 현상 발생함. C 언어에서는 `free` 함수를 통해 메모리를 반환하며, 자바에선 `가비지 콜렉션(Garbage Collection)`에 의해 자동으로 메모리가 반환됨.
- `스택 영역` : 함수 호출 시 생성되는 `지역변수`, `매개변수` 등의 데이터가 일시적으로 저장되는 영역으로 `컴파일 타임`에 할당받을 메모리 크기가 결정됨. 함수를 호출하면 `동적`으로 스택 영역을 할당받아 데이터가 저장되고, 함수 호출이 완료되면 할당받은 메모리를 반환한다. 힙과 인접한 방향으로 점점 커져 스택 포인터와 힙 포인터가 만나면 메모리가 소진되었다는 의미
`푸시(push)` 동작으로 데이터를 저장하고, `팝(pop)`동작으로 데이터를 인출함. 데이터 인출시 `후입선출(Last-In-First-Out,LIFO)` 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 먼저 인출된다.

---
- __정적 할당 영역__ : 코드영역과 데이터 영역은 프로그램 시작시 고정적으로 메모리 할당 받음
- __동적 할당 영역__ : 힙 영역과 스택 영역은 메모리를 동적으로 할당 받음. 힙 영역 ( 낮은 주소에서 높은 주소 방향으로 메모리 할당), 스택 영역 ( 높은 주소에서 낮은 주소 방향으로 메모리가 할당)

- 만약 두 영역이 겹쳐 할당받을 메모리가 없게 되면 서로의 영영을 침범할 수 있음. 이 때 스택이 힙 영역을 침범하는 경우를 `스택 오버플로우(Stack Overflow)`, 힙이 스택 영역을 침범하는 경우를 `힙 오버플로우(Heap Overflow)`라고 함.



- __프로세스 제어 블록 (PCB :Process Control Block)__
  - 특정 프로세스를 관리할 때 필요한 정보를 포함하는 운영체제 커널의 자료구조.
  - CPU는 한정된 자원을 가지기 때문에 각 프로세스는 돌아가면서 한정된 시간만큼 CPU를 사용하고, 타이머 인터럽트가 발생하면 다음 프로세스에게 차례를 양보한다.
  - 운영체제는 빠르게 번갈아 실행되는 이런 프로세스들을 스케줄링,제어할 필요가 있는데 이 때 각 프로세스 고유의 PCB에 저장된 정보를 사용한다.
  - 커널 영역에 각 프로세스에 대한 PCB 를 생성하고 프로세스의 상태 및 관련정보를 추적하며, 프로세스 완료 후 제거된다.
 
  - 프로세스가 CPU를 점유하여 작업처리하다가, 프로세스 __상태 전이__ 가 일어나면 CPU를 반환해야 하는데, 이때 진행중이던 작업을 PCB에 저장했다가, 다시 프로세싱 순서가 돌아오면, PCB 로부터 해당 정보를 CPU에 넘겨와 작업을 계속할 수 있음</br>
    <img width="230" alt="Screenshot 2024-03-06 at 3 42 10 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/973e7726-49cd-4210-9f53-138bcede3175">
  - `PID (Process ID)`:  프로세스 식별자
  - `프로세스 상태` : 생성, 준비, 실행, 대기, 완료
  - `PC (Program Counter)`: 현재 실행 중인 프로그램 명령어의 주소를 가리키는 레지스터 값. 프로세스는 다음에 실행할 명령어를 PC의 값에 따라 결정한다. 
  - `레지스터 값` : 프로세스가 현재 사용중인 레지스터 값을 저장하여 프로세스가 실행되는 동안 레지스터 값 유지되도록 한다.
  - `메모리 관리정보` : 프로세스가 사용하는 메모리 주소범위, 페이지 테이블 정보같은 메모리관리에 필요한 정보를 포함. 
  - `스케줄링 정보` (프로세스 우선순위) CPU 점유시간, 대기시간 등 스케줄링과 관련된 정보 포함. 운영체제는 이 정보를 기반으로 프로세스 스케줄링 알고리즘을 실행해 어떤 프로세스를 실행시킬지 결정.
  - `입출력 상태 정보` : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등
  - `회계정보`
  - `프로세스 계정정보` : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
  - `포인터` : 부모 프로세스에 대한 포인터, 자식 프로세서에 대한 포인터, 프로세서가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등


### 프로세스 상태관리
#### 프로세스 상태 변화 : 생성(New), 준비(Ready), 실행(Run), 대기(Wait),종료(Exit)
<img width="552" alt="Screenshot 2024-03-06 at 9 41 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1231662f-7c57-4a87-be02-f4d8888d8819">


- 준비->실행 : 준비 큐 앞에 있던 프로세스가 프로세스를 점유, 표기법: Dispatch(프로세스 이름)
- 실행->준비 : 프로세스가 프로세서를 독점하지 못하도록 인터럽트 클락(interruptClock) 을 두어 할당된 시간동안만 프로세서를 점유 표기법: Timeout(프로세스 이름)
- 실행->대기(보류) : 할당된 시간 이전에 실행상태의 프로세스에 입출력 연산 등이 필요하거나 새로운 자원요청의 문제로 프로세서를 스스로 양도하는 상태, 표기법: block(프로세스이름)
- 대기(보류)->준비 : block 상태의 프로세스가 입출력 작업이 끝나면 대기에서 준비상태가 된다, 표기법: wakeup(프로세스 이름)

### 부모 프로세스와 자식 프로세스
#### 프로세스 생성방법
- 사용자가 프로그램을 직접 실행
- 한 프로세스가 다른 프로세스를 생성
    - 프로세스 생성 __시스템 호출__ 이용
    - 부모 프로세스: 시스템 호출을 하는 프로세스
    - 자식 프로세스: 시스템 호출을 통해 새로 생성된 프로세스

### 프로세스 생성 : 시스템 호출 (시스템 콜)
:fork, wait, exec, dup, dup2, pipe...

#### UNIX, Linux : fork()
- 자식 프로세스는 부모 프로세스의 복제본
  <img width="587" alt="Screenshot 2024-03-06 at 4 11 28 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4631da03-b550-4a15-bb90-f16cc3ec745a">

프로세스는 프로그램을 실행 시 생성된다. 이때 운영체제가 프로그램 코드를 메모리의 `코드영역`에 할당하고 PCB를 생성한 후 메모리의 `데이터영역`, `스택영역`을 확보하여 프로세스를 실행한다.
`유닉스 계열`의 운영체제의 경우 새로운 프로세스를 생성할 때 위 과정을 모두 거치지 않고, `fork` 시스템 호출을 통해 기존 프로세스를 복사하여 새로운 프로세스를 생성한다. 이때 fork 시스템 호출하는 프로세스는 부모 프로세스, 새로 만들어진 프로세스는 자식 프로세스가 되어 계층 구조를 형성함.
fork 를 호출하면 PCB 를 포함한 부모 프로세스 대부분이 자식 프로세스에 복사되어 동일한 프로세스 생성됨. 다만 `PID`, `PPID`, `CPID` 등 일부 데이터가 수정됨. PPID는 부모프로세스의 PID, CPID 는 자식프로세스의 PID 이다.</br>

<img width="337" alt="Screenshot 2024-03-06 at 10 45 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/28f94312-b828-4e39-b722-6bbb937d817d">

C언어 fork 예제코드 
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void main() {

  pid_t pid;

  printf("first_PID: %ld\n", (long)getpid());
  printf("first_PPID: %ld\n", (long)getppid());
  printf("---------------------\n");

  pid = fork();

  while(1) {

    if(pid < 0) {
      printf("Error");
      exit(-1);
    }
    else if(pid == 0) {
      printf("Child Process!\n");
    }
    else {
      printf("Parent Process!\n");
    }

    printf("PID: %ld\n", (long)getpid());
    printf("PPID: %ld\n", (long)getppid());
    printf("saved PID: %ld\n", (long)pid);
    printf("---------------------\n");

    sleep(1);
  }
}
```
실행결과
<img width="324" alt="Screenshot 2024-03-06 at 10 54 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/2963a502-cc86-4482-9602-785332f0d46e">

실행 결과를 살펴보면 first_PID와 first_PPID가 부모 프로세스의 PID, PPID와 동일하다는 것을 볼 수 있다. 부모 프로세스와 자식 프로세스가 동기화되어 실행되는 것 처럼 보이지만 실제로는 독립적으로 실행되고 있다.
fork 시스템 호출을 요청하면 부모 프로세스에는 자식 프로세스의 PID를 리턴하고, 자식 프로세스에는 `0`을 리턴합니다. 또한 자식 프로세스는 부모 프로세스의 PCB를 상속받았기 때문에 `프로그램 카운터(PC)가 동일`하여 fork 시스템 호출을 요청한 이후의 코드가 실행됩니다. 그렇기 때문에 자식 프로세스에서는 first_PID와 first_PPID를 출력하지 않습니다.


#### UNIX, Linux : exec()
- 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행
  <img width="587" alt="Screenshot 2024-03-06 at 4 12 46 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/97861f97-f923-4eb5-8d48-046051fcb22a">


자식 프로세스에서 새로운 프로그램을 실행하려면  `exec` 시스템 호출을 요청하면 된다. exec 시스템 호출을 요청하면 자식 프로세스의 코드 영역을 새로운 코드로 교체하고 PCB에서 프로그램 카운터나 각종 레지스터, 파일 정보 등이 리셋된다.
<img width="503" alt="Screenshot 2024-03-06 at 11 09 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0cf76854-faad-46da-b920-eb51aafdb37b">

exec 예제코드: parent C
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void main() {

  pid_t cpid;

  printf("parent process!!\n");

  cpid = fork();

  if(cpid == 0) {
    execl("./child", "./child", NULL);
    printf("child process failed to exec\n");
    exit(0);
  }

  wait(NULL);
  exit(0);
}
```
exec 예제 코드: child
```
#include <stdio.h>
#include <stdlib.h>

void main() {
  printf("child process!!\n");
  exit(0);
}
```
 <img width="326" alt="Screenshot 2024-03-06 at 11 11 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a42e9a3c-cf0a-47d9-a40d-2aa1f30c9c9c">

부모 프로세스가 먼저 종료되면 자식 프로세스도 종료되기 때문에 parent 코드에서 wait 함수를 통해 자식 프로세스와 동기화 시킨다.

parent를 실행하면 fork 시스템 호출에 의해 자식 프로세스가 생성되고, exec 시스템 호출에 의해 자식 프로세스는 child를 실행한다. 코드 영역이 child 코드로 변경되었기 때문에 “child process failed to exec” 라는 메시지는 출력되지 않는다.

fork와 exec를 통해 프로세스를 생성하는 방식은 프로세스 생성 과정 전체를 거치지 않기 때문에 프로세스 생성 속도가 빠르고 추가 작업 없이 자원의 상속이 가능하여 시스템 관리에 효율적.
  
#### Windows : CreateProcess()
- 자식 프로세스는 새로운 프로그램으로 생성
  <img width="585" alt="Screenshot 2024-03-06 at 4 14 04 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/047b338b-3b00-4bd6-8b63-6b57b7f36d24">
  
#### 부모 프로세스와 자식 프로세스
- 프로세스 종료 방법
  - 프로세스가 모든 처리를 완료(정상적 종료)
  - 부모 프로세스에 의해 자식 프로세스가 강제 종료
      - 프로세스 종료 __시스템 호출__ 이용
      - 자식 프로세스 생성시 얻은 자식 PID 이용
  - 부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료

### 전통적인 프로세스
- 하나의 프로그램을 실행하기 위한 기본적인 단위
- 자원 소유 단위 (하나의 메모리 구조)
- 디스패칭의 단위 (하나의 제어흐름)
- 프로세스 내에서 다중처리 불가능

## 쓰레드
### 전통적인 프로세스
### 쓰레드 (thread)
### 프로세스 비교
### 쓰레드와 프로세스
### 다중 쓰레드로 구성된 프로세스

[참고](https://didu-story.tistory.com/311)
[참고](https://huimang2.github.io/etc/computer-process.html)
