<강의,교재,동영상 꼼꼼히 구조체,포인터,템플린 어려움>
중간과제물	온라인과제물	교재 1장～3장(해당 멀티미디어강의 1강～3강 포함)</br> 	              
형성평가	진도20 </br> 	 
기말시험	온라인출석시험(객관식)	교재4장~15장(해당 멀티미디어 강의 4강~15강 포함)   </br> 	  
### 목차
1. [운영체제 소개](#운영체제-소개)
2. [프로세스와 쓰레드](#프로세스와-쓰레드)
3. [프로세스 스케줄링](#프로세스-스케줄링)
4. [병행 프로세스 1](#병행-프로세스-1)
5. [병행 프로세스 2](#병행-프로세스-2)
6. [교착상태 1](#교착상태-1)
7. [교착상태 2](#교착상태-2)
8. [메모리 관리](#메모리-관리)
9. [가상 메모리](#가상-메모리)
10. [페이지 교체 알고리즘](#페이지-교체-알고리즘)
11. [장치관리](#장치관리)
12. [저장장치 및 파일관리](#저장장치-및-파일관리)
13. [분산 운영체제](#분산-운영체제)
14. [운영체제 보안](#운영체제-보안)
15. [운영체제 사례](#운영체제-사례)

# 운영체제 소개
#### 학습목표
- 운영체제의 개념과 역할을 설명할 수 있다.
- 운영체제의 구성을 설명할 수 있다.
- 운영체제의 유형을 설명할 수 있다.

## 1. 운영체제란 무엇인가?
  운영체제는 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌
  
  <img width="675" alt="Screenshot 2024-03-06 at 5 52 51 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/d7ebdd9d-7e2a-45ed-8e1e-aef3f97bd6ef">


### 컴퓨터 시스템의 구성
  - __하드웨어__ : cpu,메모리,저장장치,입출력장치,네트워크 장치 등
  - __소프트웨어__ : 브라우저 pdf viewer, 프로그램언어
  - __운영체제__
      - 대표적인 시스템 소프트웨어 : Windows11, Mac OS, 컴파일러, Linux (응용소프트웨어와 하드웨서 사이에서 매개체역할)</br>
      - 하드웨어와 응용프로그램 사이에 운영체제 위치하여, 컴퓨터 시스템이 안정적이고 효율적으로 동작하도록 함
      - 컴퓨터 시스템의 자원(하드웨어/소프트웨어 자원,데이터)을 관리 :(예시) 저장장치의 데이터 읽어오기, 키보드/마우스제어, 프로그램 동시실행시 cpu/메모리 효율적 관리</br> 
      - 사용자 지원 : 사용자명령 해석/실행, 사용자와 하드웨어 사이 매개체 역할, 편의성 제공
  - __커널(kernel)이란?__
    - 컴퓨터 전원이 켜짐과 동시에 운영체제 중 항상 필요한 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려 사용. 이때 메모리에 상주하는 운영체제의 부분을 커널(kernel)이라고 하며 운영체제의 핵심적인 부분을 뜻한다.
    - __커널 구성방식__ :
      - __일체형커널__(운영체제 모든 서비스가 커널내 포함 UNIX,Linux): 커널 내부요소 상호작용,한 요소라도 오류발생시 시스템 전체장애
      - __마이크로커널__(운영체제 요소 대부분을 커널 외부로 분리): 유지보수용이, 안정적, 프로세스간 통신(IPC)필요해 성능저하
  - __CPU 모드__
    - __커널모드(수퍼바이저모드)__: 하드웨어 직접제어, 운영체제(OS)가 CPU를 사용하는 모드. `시스템 콜`을 통해 `커널모드`로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어를 실행한다.
    - __사용자모드(보호모드)__ : 사용자모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당모드에서는 하드웨어(디스크,I/O)등에 접근할 수 없다. 접근을 위해서 `시스템 콜(system call)` 을 사용해야 한다. 사용자 애플리케이션의 각 스레드는 고유의 사용자모드 스택을 갖는다.
      
<img width="689" alt="Screenshot 2024-03-06 at 6 00 35 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c65e5f45-804a-4b0d-accc-b39bfcf9520b">
    
위 그림같이 사용자 process 는 user mode에서 실행되다가 시스템 자원을 사용해야 할때 시스템 콜을 하여 커널모드로 전환한 뒤 작업을 수행하고 완료 후에 다시 사용자 모드로 전환한다.

  - __시스템호출__ : 응용프로그램이 하드웨어에 대한 제어가 필요한 경우 이용
    
  - C 언어를 프로그램을 통한 시스템 콜 이해
```
#include <stdio.h>
int main()
{
  ...
  printf("Hello World!");
  ...
  return 0;
}
```
`printf()` 함수는 `user mode`에서 수행되어 `stdio 라이브러리`를 호출한다. stdio 라이브러리는 `시스템 콜`인 `write()`를 호출하고, 실행의 흐름은 `kernel mode` 로 바뀐다. 커널은 호출을 실행하여 모니터에 문자열을 출력하고 실행의 흐름은 다시 user mode 로 넘어와 printf()의 함수의 다음단계를 진행한다.

<img width="578" alt="Screenshot 2024-03-06 at 6 22 12 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/42d75bb6-2b89-4d34-81f9-3ac1d4a130e9">


### 운영체제의 구성
  - 프로세스 관리자 : 프로세스 생성 및 삭제, CPU 할당을 위한 스케쥴 결정, 프로세스 상태관리하며 상태 전이처리
  - 메모리 관리자 : 메모리(주기억장치) 공간에 대한 요구의 유효성확인, 메모리할당 및 회수, 메모리 공간 보호
  - 파일 관리자 : 모든 파일관리, 저장장치 공간관리, 파일접근제한 관리
  - 장치 관리자 : 컴퓨터 시스템의 모든 장치(하드디스크,SSD,키보드,마우스,프린터,유무선네트워크카드)관리,

    
### 운영체제 유형
  - 일괄처리 운영체제 : Batch processing 작업을 모아 순차적으로 처리하는 방식
  - 시분할 운영체제 : (대화형운영체제) Time-sharing 각 사용자의 프로그램을 한 번에 조금씩 수행, 응답시간 단축
  - 실시간 운영체제 : Real-time 원하는 시간 내에 프로그램의 결과를 얻을 수 있는 방식, 증권관리시스템, 미사일제어시스템
  - 분산 운영체제 : 분산시스템 (2개 이상의 컴퓨터시스템이 네트워크로 서로 연결되어 서로 자원을 이용하는 시스템)을 관리하는 운영체제
    
---

# 프로세스와 쓰레드
## 프로세스
### 프로세스의 개요
- __프로세스(process)__: 실행 중인 프로그램의 인스턴스, 프로그램은 데이터 상태로 `보조기억장치`에 저장되어 있으며, 프로그램이 `실행`되면 `메모리`에 적재되어 `프로세스` 된다.
  - 프로그램: 동작하지 않는 정적,수동적 개체
  - 프로세스 :동작하는 능동적 개체
- 운영체제로부터 자원을 할당 받아 동작
    - 자원: CPU, 메모리, 입출력장치, 파일 등
    - 동작: CPU가 프로세스의 명령을 실행

#### 프로세스 종류
- __포그라운드 프로세스 (Foreground Process)__: 사용자와 상호작용하면서 실행되는 프로세스. 주로 사용자 인터페이스를 통해 입력을 받거나 출력을 제공하고, 명령을 처리, 작업을 수행한다. 사용자가 직접 보고 제어할 수 있으며, 사용자와의 상호작용을 위해 우선순위를 가지고 실행된다.
- __백그라운드 프로세스 (Background Process)__ : 사용자와 상호작용하지 않고 실행되는 프로세스. 주로 시스템 작업, 보조 작업 처리하는데 사용됨. 사용자의 입력,제어를 기다리지 않고 실행되기에 높은 우선순위 가짐. 일반적으로 백그라운드 프로세스는 시간이 오래 걸리는 작업이나 자동화된 작업을 처리하는데 사용됨

예시) 웹 브라우저 실행한다고 가정. 
웹 브라우저 자체는 포그라운드 프로세스로 실행되며, 사용자가 웹 페이지를 찾아보거나 입력하면 이를 처리함.웹 브라우저에서 파일을 다운로드하는 경우, 다운로드 작업은 백그라운드 프로세스로 실행됨. 사용자는 다운로드 작업이 백그라운드에서 진행되는 동안에도 브라우저를 계속 사용 가능함.
      
### 프로세스와 운영체제 
- 운영체제(프로세스 관리자)가 처리하는 작업
  - 프로세스를 생성 및 종료
  - 프로세스를 실행시키기 위한 스케줄링 작업
  - 프로세스의 상태 관리
    
### 프로세스의 구성 : 

- ### __메모리 구조__ : 프로그램 실행에 직접적으로 필요한 코드와 데이터 (커널영역, 사용자영역으로 나뉨)
- 사용자 영역에서 프로세스는 코드, 데이터, 힙, 스택 영역으로 나뉨
  
<img width="222" alt="Screenshot 2024-03-06 at 9 54 40 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4f2d3be8-f5e2-462f-ad9a-e5ab8e990e8a">

- __커널 영역__ : PCB 가 저장됨
- __코드 영역__ : 실행하는 프로그램 코드가 기계어로 저장되며 `텍스트 영역`이라고도 함. 데이터 저장이 아닌, CPU가 실행할 `명령어`가 저장되어 있어서 쓰기가 금지된 `read-only` 영역임. CPU는 코드 영역에 저장된 명령어를 하나씩 처리함
- __데이터 영역__ : 프로그램 실행 중에 유지할 데이터 저장. 프로그램 가상 주소 공간, `전역변수`, `정적변수` 저장하고 실행될 때 할당되고, 프로그램 종료되면 소멸. 
- __힙 영역__ : 사용자가 직접 관리 가능한 메모리 영역으로,`런 타임`에 할당받을 메모리 크기가 결정됨. 코드영역과 별도로 유지되는 자유영역, C 계열의 `malloc()`과 java 계열의 `new()` 명령어 통해 인스턴스 생성하면, `동적`으로 힙 영역 메모리 할당받아 데이터가 저장됨. 
힙 영역은 사용자가 직접 `메모리를 반환`해야 하며, 반환하지 않으면 지속적으로 메모리 공간을 차지하는 `메모리 누수 (Memory Leak)` 현상 발생함. C 언어에서는 `free` 함수를 통해 메모리를 반환하며, 자바에선 `가비지 콜렉션(Garbage Collection)`에 의해 자동으로 메모리가 반환됨.
- __스택 영역__ : 함수 호출 시 생성되는 `지역변수`, `매개변수` 등의 데이터가 일시적으로 저장되는 영역으로 `컴파일 타임`에 할당받을 메모리 크기가 결정됨. 함수를 호출하면 `동적`으로 스택 영역을 할당받아 데이터가 저장되고, 함수 호출이 완료되면 할당받은 메모리를 반환한다. 힙과 인접한 방향으로 점점 커져 스택 포인터와 힙 포인터가 만나면 메모리가 소진되었다는 의미
`푸시(push)` 동작으로 데이터를 저장하고, `팝(pop)`동작으로 데이터를 인출함. 데이터 인출시 `후입선출(Last-In-First-Out,LIFO)` 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 먼저 인출된다.

- __정적 할당 영역__ : 코드영역과 데이터 영역은 프로그램 시작시 고정적으로 메모리 할당 받음
- __동적 할당 영역__ : 힙 영역과 스택 영역은 메모리를 동적으로 할당 받음. 힙 영역 ( 낮은 주소에서 높은 주소 방향으로 메모리 할당), 스택 영역 ( 높은 주소에서 낮은 주소 방향으로 메모리가 할당)

- 만약 두 영역이 겹쳐 할당받을 메모리가 없게 되면 서로의 영영을 침범할 수 있음. 이 때 스택이 힙 영역을 침범하는 경우를 `스택 오버플로우(Stack Overflow)`, 힙이 스택 영역을 침범하는 경우를 `힙 오버플로우(Heap Overflow)`라고 함.



- ### __프로세스 제어 블록 (PCB :Process Control Block)__
  - 특정 프로세스를 관리할 때 필요한 정보를 포함하는 운영체제 커널의 자료구조.
  - CPU는 한정된 자원을 가지기 때문에 각 프로세스는 돌아가면서 한정된 시간만큼 CPU를 사용하고, 타이머 인터럽트가 발생하면 다음 프로세스에게 차례를 양보한다.
  - 운영체제는 빠르게 번갈아 실행되는 이런 프로세스들을 스케줄링, 제어할 필요가 있는데 이 때 각 프로세스 고유의 PCB에 저장된 정보를 사용한다.
  - `커널 영역`에 각 프로세스에 대한 `PCB 를 생성`하고 프로세스의 `상태 및 관련정보를 추적`하며, 프로세스 완료 후 `제거`된다.
 
  - 프로세스가 CPU를 점유하여 작업처리하다가, 프로세스 `상태 전이`가 일어나면 CPU를 반환해야 하는데, 이때 진행중이던 작업을 PCB에 저장했다가, 다시 프로세싱 순서가 돌아오면, PCB 로부터 해당 정보를 CPU에 넘겨와 작업을 계속할 수 있다.</br>
  
    <img width="230" alt="Screenshot 2024-03-06 at 3 42 10 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/973e7726-49cd-4210-9f53-138bcede3175">
    
  - `PID (Process ID)`:  프로세스 식별자
  - `프로세스 상태` : 생성, 준비, 실행, 대기, 완료
  - `PC (Program Counter)`: 현재 실행 중인 프로그램 명령어의 주소를 가리키는 레지스터 값. 프로세스는 다음에 실행할 명령어를 PC의 값에 따라 결정한다. 
  - `레지스터 값` : 프로세스가 현재 사용중인 레지스터 값을 저장하여 프로세스가 실행되는 동안 레지스터 값 유지되도록 한다.
  - `메모리 관리정보` : 프로세스가 사용하는 메모리 주소범위, 페이지 테이블 정보같은 메모리관리에 필요한 정보를 포함. 
  - `스케줄링 정보` (프로세스 우선순위) CPU 점유시간, 대기시간 등 스케줄링과 관련된 정보 포함. 운영체제는 이 정보를 기반으로 프로세스 스케줄링 알고리즘을 실행해 어떤 프로세스를 실행시킬지 결정.
  - `입출력 상태 정보` : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등
  - `회계정보`
  - `프로세스 계정정보` : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
  - `포인터` : 부모 프로세스에 대한 포인터, 자식 프로세서에 대한 포인터, 프로세서가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등


### 프로세스 상태관리
#### 프로세스 상태 변화 : 생성(New), 준비(Ready), 실행(Run), 대기(Wait),종료(Exit)

<img width="552" alt="Screenshot 2024-03-06 at 9 41 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1231662f-7c57-4a87-be02-f4d8888d8819">


- __준비 -> 실행__ : 준비 큐 앞에 있던 프로세스가 프로세스를 점유, 표기법: Dispatch(프로세스 이름)
- __실행 -> 준비__ : 프로세스가 프로세서를 독점하지 못하도록 인터럽트 클락(interruptClock) 을 두어 할당된 시간동안만 프로세서를 점유 표기법: Timeout(프로세스 이름)
- __실행 -> 대기(보류)__ : 할당된 시간 이전에 실행상태의 프로세스에 입출력 연산 등이 필요하거나 새로운 자원요청의 문제로 프로세서를 스스로 양도하는 상태, 표기법: block(프로세스이름)
- __대기(보류) -> 준비__ : block 상태의 프로세스가 입출력 작업이 끝나면 대기에서 준비상태가 된다, 표기법: wakeup(프로세스 이름)

### 부모 프로세스와 자식 프로세스
#### 프로세스 생성방법
- 사용자가 프로그램을 직접 실행
- 한 프로세스가 다른 프로세스를 생성
    - 프로세스 생성 __시스템 호출__ 이용
    - 부모 프로세스: 시스템 호출을 하는 프로세스
    - 자식 프로세스: 시스템 호출을 통해 새로 생성된 프로세스

### 프로세스 생성 : 시스템 호출 (시스템 콜)
:fork, wait, exec, dup, dup2, pipe...

#### UNIX, Linux : fork()
- 자식 프로세스는 부모 프로세스의 복제본
- 
  <img width="587" alt="Screenshot 2024-03-06 at 4 11 28 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/4631da03-b550-4a15-bb90-f16cc3ec745a">

프로세스는 프로그램을 실행 시 생성된다. 이때 운영체제가 프로그램 코드를 메모리의 `코드영역`에 할당하고 PCB를 생성한 후 메모리의 `데이터영역`, `스택영역`을 확보하여 프로세스를 실행한다. </br>
`유닉스 계열`의 운영체제의 경우 새로운 프로세스를 생성할 때 위 과정을 모두 거치지 않고, `fork` 시스템 호출을 통해 기존 프로세스를 복사하여 새로운 프로세스를 생성한다. 이때 fork 시스템 호출하는 프로세스는 부모 프로세스, 새로 만들어진 프로세스는 자식 프로세스가 되어 계층 구조를 형성함.</br>
fork 를 호출하면 PCB 를 포함한 부모 프로세스 대부분이 자식 프로세스에 복사되어 동일한 프로세스 생성됨. 다만 `PID`, `PPID`, `CPID` 등 일부 데이터가 수정됨. PPID는 부모프로세스의 PID, CPID 는 자식프로세스의 PID 이다.</br>

<img width="337" alt="Screenshot 2024-03-06 at 10 45 58 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/28f94312-b828-4e39-b722-6bbb937d817d">

C언어 fork 예제코드 
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void main() {

  pid_t pid;

  printf("first_PID: %ld\n", (long)getpid());
  printf("first_PPID: %ld\n", (long)getppid());
  printf("---------------------\n");

  pid = fork();

  while(1) {

    if(pid < 0) {
      printf("Error");
      exit(-1);
    }
    else if(pid == 0) {
      printf("Child Process!\n");
    }
    else {
      printf("Parent Process!\n");
    }

    printf("PID: %ld\n", (long)getpid());
    printf("PPID: %ld\n", (long)getppid());
    printf("saved PID: %ld\n", (long)pid);
    printf("---------------------\n");

    sleep(1);
  }
}
```

<img width="324" alt="Screenshot 2024-03-06 at 10 54 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/2963a502-cc86-4482-9602-785332f0d46e">

실행 결과를 살펴보면 `first_PID`와 `first_PPID`가 부모 프로세스의 `PID`, `PPID`와 동일하다는 것을 볼 수 있다. 부모 프로세스와 자식 프로세스가 동기화되어 실행되는 것처럼 보이지만 실제로는 독립적으로 실행되고 있다.
fork 시스템 호출을 요청하면 부모 프로세스에는 `자식 프로세스의 PID`를 리턴하고, 자식 프로세스에는 `0`을 리턴합니다. 또한 자식 프로세스는 부모 프로세스의 PCB를 상속받았기 때문에 `프로그램 카운터(PC)가 동일`하여 fork 시스템 호출을 요청한 이후의 코드가 실행됩니다. 그렇기 때문에 _자식 프로세스에서는 first_PID와 first_PPID를 출력하지 않습니다._


#### UNIX, Linux : exec()
- 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행
  
  <img width="587" alt="Screenshot 2024-03-06 at 4 12 46 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/97861f97-f923-4eb5-8d48-046051fcb22a">


자식 프로세스에서 새로운 프로그램을 실행하려면  `exec` 시스템 호출을 요청하면 된다. exec 시스템 호출을 요청하면 자식 프로세스의 코드 영역을 새로운 코드로 교체하고 PCB에서 프로그램 카운터나 각종 레지스터, 파일 정보 등이 리셋된다.

<img width="503" alt="Screenshot 2024-03-06 at 11 09 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0cf76854-faad-46da-b920-eb51aafdb37b">

exec 예제코드: parent C
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void main() {

  pid_t cpid;

  printf("parent process!!\n");

  cpid = fork();

  if(cpid == 0) {
    execl("./child", "./child", NULL);
    printf("child process failed to exec\n");
    exit(0);
  }

  wait(NULL);
  exit(0);
}
```
exec 예제 코드: child
```
#include <stdio.h>
#include <stdlib.h>

void main() {
  printf("child process!!\n");
  exit(0);
}
```
 <img width="326" alt="Screenshot 2024-03-06 at 11 11 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a42e9a3c-cf0a-47d9-a40d-2aa1f30c9c9c">

부모 프로세스가 먼저 종료되면 자식 프로세스도 종료되기 때문에 parent 코드에서 wait 함수를 통해 자식 프로세스와 동기화 시킨다.

parent를 실행하면 fork 시스템 호출에 의해 자식 프로세스가 생성되고, exec 시스템 호출에 의해 자식 프로세스는 child를 실행한다. 코드 영역이 child 코드로 변경되었기 때문에 “child process failed to exec” 라는 메시지는 출력되지 않는다.

fork와 exec를 통해 프로세스를 생성하는 방식은 프로세스 생성 과정 전체를 거치지 않기 때문에 프로세스 생성 속도가 빠르고 추가 작업 없이 자원의 상속이 가능하여 시스템 관리에 효율적.
  
#### Windows : CreateProcess()
- 자식 프로세스는 새로운 프로그램으로 생성
  
  <img width="585" alt="Screenshot 2024-03-06 at 4 14 04 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/047b338b-3b00-4bd6-8b63-6b57b7f36d24">
  
#### 부모 프로세스와 자식 프로세스
- 프로세스 종료 방법
  - 프로세스가 모든 처리를 완료(정상적 종료)
  - 부모 프로세스에 의해 자식 프로세스가 강제 종료
      - 프로세스 종료 __시스템 호출__ 이용
      - 자식 프로세스 생성시 얻은 자식 PID 이용
  - 부모 프로세스가 종료되는 경우 운영체제가 자식 프로세스 종료

### 전통적인 프로세스
- 하나의 프로그램을 실행하기 위한 기본적인 단위
- 자원 소유 단위 (하나의 메모리 구조)
- 디스패칭의 단위 (하나의 제어흐름)
- 프로세스 내에서 다중처리 불가능

## 쓰레드
### 전통적인 프로세스
### 쓰레드 (thread)
### 프로세스 비교
### 쓰레드와 프로세스
### 다중 쓰레드로 구성된 프로세스

[참고](https://didu-story.tistory.com/311)
[참고](https://huimang2.github.io/etc/computer-process.html)

---

# 프로세스 스케줄링
CPU 스케줄링 (CPU Scheduling) 이란 운영체제가 프로세스에 합리적으로 CPU 자원을 할당하는 정책을 만드는 것을 말한다. 멀티태스킹을 위해 운영체제가 CPU의 가동시간을 적절히 나누어 프로세스에게 사용시간을 분배한다. 이때 시스템과 사용자의 입장에서 CPU 성능에 대한 척도가 달라진다.

#### 1. 시스템 입장에서의 성능 척도
- CPU 사용률(CPU Utilization) : 전체 시스템 시간 중 CPU 가 작업을 처리하는 시간의 비율
- 처리량 (Throughtput) : CPU 가 단위 시간당 처리하는 프로세스 개수
  
#### 2. 사용자 입장에서의 성능 척도
- 대기시간(Waiting Time) : 프로세스가 준비 상태에서 CPU를 할당 받을 때까지 대기한 시간
- 응답시간(Response Time) : 프로세스의 명령 요청 후 응답이 올 때까지의 시간
- 반환시간(Turnaround Time): 프로세스가 시작해서 끝날 때까지 걸리는 시간

시스템 입장에서는 CPU를 쉬지않고 최대한 많이 가동시키는 것이 중요하고, 사용자 입장에서는 요청한 작업이 빨리 처리되는 것이 중요하므로 운영체제는 상황에 맞게 CPU 스케줄링을 설계할 필요가 있다.
DPU 스케줄링은 스케줄링 방식에 따라 `선점형`과 `비선점형`으로 나뉜다.

`선점(preemptive)`이란 빼앗을 수 있음을 의미한다. 즉 선점형 스케줄링은 운영체제가 필요하다고 판단할 경우 실행중인 프로세스를 중단하고, 다른 프로세스에게 CPU 자원을 할당하여 실행할 수 있다.</br>
반면 `비선점` 스케줄링은 프로세스에게 할당된 CPU를 강제로 빼앗을 수 없고, 프로세스의 사용이 끝난 후에야 다른 프로세스에게 CPU 자원 할당이 가능하다. 

선점형 스케줄링 경우 하나의 프로세스가 자원 독점하지 못하게 막을 수도 있지만, `문맥교환` 과에서 `오버헤드`가 발생할 수 있다. 반면 비선점형 스케줄링의 경우 문맥교환에 대한 오버헤드가 없지만, 전체 시스템 처리율이 떨어질 수 있다.

운영체제는 PCB를 `스케줄링 큐(Queue)`에서 리스트 형태로 관리한다. 보통 `큐`는 `선입선출 방식`을 따르는 자료구조이지만, `스케줄링 큐`는 스케줄링 알고리즘에 따라 다른 자료구조를 가질 수 있다. 스케줄링 큐는 프로세스 `상태`에 따라 `준비 큐(Ready Queue)`, `대기 큐(Waiting Queue)` 등 여러 큐가 존재한다. 

## 스케줄링 성능 평가 기준
### 1. 평균 대기시간 (Average waiting time)
- 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값
### 2. 평균 반환시간 (Average trunaround time)
- 각 프로세스가 생성된 시점 ( 여기서는 준비 큐에 들어온 시점과 동일한 것으로 가정) 부터 수행이 완료된 시점까지의 소요시간의 평균값
  
## 비선점형 스케줄링
### 1. 선입 선처리 (FCFS, First Come First Served) 알고리즘
- 프로세스는 준비 큐에서 도착순서에 따라 디스패치되며, 일단 한 프로세스가 CPU를 차지하면, 그 프로세스의 수행이 완료된 후에 그 다음 프로세스가 CPU를 차지하고 수행된다.
- 공정해 보이나, 짧은 작업이 긴 작업을 기다리게 되거나,중요 프로세스가 나중에 수행될 수 있는 불합리함이 있어 대화식 시스템에 부적합하다. 프로세스들의 __도착순서__ 에 따라 __평균반환시간이 크게 변한다.__
- 직관적이고 단순한 알고리즘이지만 평균 대기시간이 길어지는 `호위 효과(Convoy Effect)` 문제가 있다.
  
<img width="493" alt="Screenshot 2024-03-09 at 10 29 41 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/26afdee6-6968-4c13-913c-424dd3bc8a97"></br>


<img width="339" alt="Screenshot 2024-03-09 at 10 33 24 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/111ec01c-16ed-4320-b4de-2fc5115ba452">

- P<sub>1</sub> 은 20초, P<sub>2</sub> 은 3초, P<sub>3</sub> 은 7초, P<sub>4</sub> 은 5초의 실행시간이 걸린다. 
- 도착시간이 0 초로 모두 동일하다 가정하면 __P<sub>1</sub> -> P<sub>2</sub> -> P<sub>3</sub> -> P<sub>4</sub>__ 순서로 실행됨
- P<sub>1</sub> 은 0초, P<sub>2</sub> 은 20초, P<sub>3</sub> 은 23초, P<sub>4</sub> 은 30초의 대기시간을 가지게 되어 평균 대기시간은 __18.25초__ 가 된다.
- (0 + 20 + 23 + 30) / 4 = 18.25

  
### 2. 최단 작업 우선 (SJF, Shortest Job First) 알고리즘
- FCFS 알고리즘을 보완하여 __실행시간이 짧다__ 고 추정되는 프로세스를 먼저 디스패치하여 자원할당하는 알고리즘이다.
- 일괄처리 환경에서 구현이 쉽고, 알고리즘으로 실행할 프로세스의 CPU 소요시간이 미리 주어진다.
- 위 FDFS 의 예시를 SJF 알고리즘으로 적용해 보면, 실행시간이 가장 짧은 작업부터 처리하여, __P<sub>2</sub> -> P<sub>4</sub> -> P<sub>3</sub> -> P<sub>1</sub>__ 순서대로 실행된다.
- P<sub>2</sub> 은 0초, P<sub>4</sub> 은 3초, P<sub>3</sub> 은 8초, P<sub>1</sub> 은 15초의 대기시간을 가지게 되어 평균 대기시간은 __6.5초__ 가 된다.
- (0 + 3 + 8 + 15) / 4 = 6.5

<img width="497" alt="Screenshot 2024-03-09 at 10 34 45 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f399c1a4-d638-4242-9786-b774bab58836">

  
- 짧은 작업이라도 이미 CPU가 선점되어 있다면, 비선점 방식이기 때문에 우선 실행되는 프로세스가 종료될때까지 기다릴 수 밖에 없다. 
- SJF 는 FCFS 알고리즘에서의 호위효과 문제가 해결되었지만, 실행시간이 긴 프로세스의 경우 영원이 CPU를 할당받지 못하는 기아(Starvation)현상이 발생할 수 있다.
- 실행시간을 추적하지만 사실 이 작업이 예상하기 어려운 점이 있다 (예를들어 워드작업이 얼마나 걸릴지 예상하기 힘듦) 

  
### 3. 최고 응답률 우선(HRN, Hightest Response-ratio Next) 알고리즘
- 점유의 불평등 현상이 발생하는 SJF 알고리즘을 보완하여 응답률이 높은 프로세스에게 먼저 자원을 할당하는 CPU 알고리즘이며, 다음 계산식을 통해 프로세스의 우선순위를 결정한다.
- 우선순위 = (대기시간 + 실행시간) / 실행시간 
- P<sub>2</sub> 가 처음 실행되었다고 가정하면 프로세스 순위계산은 다음과 같다.
- P<sub>1</sub> :(3 + 20 ) / 20 = 1.15
- P<sub>3</sub> : (23 + 7 ) / 7 = 4.3
- P<sub>4</sub> : (30 + 5 ) / 5 = 7
- 대기 시간이 길어질 수록 값이 커져서 우선순위가 높아지고, P<sub>4</sub>의 기아현상도 해소된다.
- 따라서 P<sub>2</sub> 실행 이후 __P<sub>4</sub> -> P<sub>3</sub> -> P<sub>1</sub>__ 순서대로 프로세스가 실행된다.

<img width="499" alt="Screenshot 2024-03-09 at 10 37 26 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b92aaafb-dbc8-4223-8efe-591bfab43969">


## 선점형 스케줄링
### 1. 라운드 로빈(RR, Round Robin) 알고리즘
- RR 알고리즘은 FCFS 알고리즘을 선점형으로 변형한 알고리즘이다. 선점형 스케줄링의 경우 정해진 시간만큼 프로세스가 돌아가면서 CPU를 사용하며, 해당 시간을 초과하면 `타임 아웃 인터럽트(Time out Interrunpt)`에 의해 CPU 점유를 뺏기고 `준비 큐`의 맨 뒤로 들어간다.</br>
- 이 `시간할당량`을 `타임 슬라이스(Time Slice)` 라고 하며, 선점형 스케줄링에선 타임 슬라이스의 `크기`가 중요하다. 타임 슬라이스가 너무 크면 비선점형과 다를바 없어 호위효과 문제가 발생할 수 있으며, 너무 작으면 잦은 문맥교환으로 인한 오버헤드가 발생해 CPU 성능이 떨어질 수 있다.
- CPU를 독점하지 않고, 공평하게 이용하며, 시분할 운영체제에 적합하다. 
  
<img width="647" alt="Screenshot 2024-03-07 at 3 52 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/78a692f4-68de-466f-9368-e94ba15a5b45">

- 도착시간이 0초로 모두 동일하고 타임 슬라이스는 5초라고 가정하면, P<sub>1</sub>(실행시간:20초)과 P<sub>3</sub>(실행시간:7초)은 타임슬라이스를 5초를 초과하여 문맥 교환이 발생한다. 그러므로 P<sub>1</sub> → (문맥교환) → P<sub>2</sub> → P<sub>3</sub> → (문맥교환) → P<sub>4</sub> → P<sub>1</sub> → (문맥교환) → P<sub>3</sub> → P<sub>1</sub> 순서로 실행됩니다.

<img width="508" alt="Screenshot 2024-03-09 at 10 36 25 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/04b021bd-427a-47d3-8443-22909c8f95fa">



### 2. 최소 잔여 시간 우선(SRT, Sortest Remaining Time)
- SJF 알고리즘을 선점형으로 변형한 알고리즘이다. 
- 선점형 스케줄링 현재 실행 중인 프로세스보다 우선순위가 더 높은 프로세스(실행시간 짧은 프로세스)가 도착하면 cpu를 뺏김
- 새로운 프로세스가 도착할 때마다 새롭게 스케줄링을 진행함
- 새로운 프로세스가 들어온 시점에서 현재까지 남은 실행시간이 가장 적은 프로세스를 먼저 실행함 ⇒ 새로 들어온 가장 짧은 프로세스가 오자마자 실행될 수 있음
- SRT 가 SJF 보다 평균 대기시간이나 평균 반환시간에서 효율적이다.
  단점
- Starvation : SJF 와 같은 이유로 실행시간이 긴 프로세스가 영원히 CPU 할당받을 수 없음
- 새로운 프로세스가 올 때마다 스케줄링을 다시하므로, 프로세스의 정확한 CPU Burst Time을 측정할 수 없다
- SRT는 실행되는 각 작업의 실행시간을 추적하여 각 프로세스가 서비스를 받은 시간이 기록되어야 하며, 때로는 선점을 위한 __문맥교환__ 해야 하므로 __SJF 보다 오버헤드가 더 크다.__
  
<img width="514" alt="Screenshot 2024-03-09 at 10 26 28 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/2cf054ff-f61c-4623-b70b-7e604feb07c4">


### 3. 다단계 큐(MQ, Multi-level Queue) 알고리즘
- MQ 알고리즘은 프로세스의 특성별로 준비 큐를 여러 개 두어 우선순위를 부여하고, 높은 우선순위에 있는 프로세스에게 먼저 자원을 할당하는 알고리즘이다.

<img width="661" alt="Screenshot 2024-03-07 at 4 14 10 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/66587112-ace8-4dcf-b1ae-ab91894cfbf6">

- 이 알고리즘은 특성별 큐 별로 서로 다른 CPU 스케줄 알고리즘을 적용할 수 있지만, 프로세스가 큐 간의 이동이 불가능하기 때문에, 우선순위가 낮은 큐에 있는 프로세스들은 기아 현상이 발생할 수 있다. 

### 4. 다단계 피드백 큐(MFQ, Multi-level Feedback Queue) 알고리즘
- MQ 알고리즘의 발전된 형태로, 프로세스가 큐 간의 이동이 가능하다.
- MQ 알고리즘의 경우, 정해진 시간동안 작업을 처리하지 못하면 동일한 우선순위의 준비 큐에 들어가지만, 
- MFQ 알고리즘의 경우, 우선순위가 낮은 큐에 들어감으로써 프로세스 기아 현상을 해결할 수 있다. 이 기법을 에이징(aging)이라고 한다.

<img width="409" alt="Screenshot 2024-03-09 at 10 38 37 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/9b286635-69ac-4180-9ce4-6f22112e357b">


[참고](https://velog.io/@inhalin/knou-os-03)
[참고](https://huimang2.github.io/etc/computer-scheduling)
[참고](https://hyuntaekhong.github.io/blog/OperatingSystem03/)
[참고](https://github.com/kim-svadoz/TIL/blob/master/ComputerScience/OS/OS.md)


---

# 병행 프로세스 1
## 병행프로세스의 개요
### 병행성 : 여러개의 프로세스 또는 쓰레드가 동시 수행되는 시스템의 특성
- 병행 프로세스 : 동시 수행되는 여러개의 프로세스 또는 쓰레드
### 병행 프로세스의 실행 형태
- 1개의 CPU : 인터리빙 형식
    
<img width="329" alt="Screenshot 2024-03-16 at 10 48 40 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/6c93e8c4-c11b-409f-a67e-10dcb701b136"></br></br>
  
- 여러개의 CPU : 병렬처리 형식

<img width="328" alt="Screenshot 2024-03-16 at 10 49 05 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/ef37de0d-9cdb-4226-bb1d-6df58818626c"></br></br>


- 멀티프로세서 시스템에서의 메모리 구조에 따라(프로세스 처리 중 cpu뿐 아니라 메로리에 따른 구분)
    
<img width="472" alt="Screenshot 2024-03-16 at 10 49 51 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/a03d404e-898f-411a-bac7-e472420c9d64"></br></br>


### 프로세스 간의 관계
#### 독립 프로세스 : 
- 수행중인 다른 프로세스에 영향을 주지도 받지도 않음
- 데이터 및 상태를 다른 프로세스와 공유하지 않음
- 프로세스의 실행
  - 결정적 : 실행결과는 입력에 의해서만 결정됨
  - 재생가능 : 시기를 다르게 실행해도 같은 입력에 대해 항상 동일한 실행결과

#### 협력 프로세스 :  
수행중인 다른 프로세스와 영향을 주고 받음
데이터 및 상태를 다른 프로세스와 공유
프로세스와 실행
  - 비결정성 : 실행결과는 실행 순서에 좌우됨
  - 재생불가능 : __다른 프로세스와의 협력 중 결과가 달라져__ 같은 입력에 대해 항상 동일한 실행결과를 보장하지 못함

## 병행성 문제 : 협력 프로세스인 경우 발생 가능한 문제
- ### 상호배제 :
- 2개 이상의 프로세스가 동시에 __임계영역__ 에 진입하지 못하도록 하는 것
- 임계영역 : 2개 이상의 프로세스가 __동시에 사용하면 안되는 공유지원__ 을 액세스하는 프로그램 코드 영역 -> A가 끝나고 나서 B처리하도록 상호배제 해야함

 <img width="344" alt="Screenshot 2024-03-16 at 11 01 17 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/5db5de77-be3b-4e5e-9708-97a25f71528c">

- ### 동기화 :
- 2개의 프로세스에 대한 처리 순서를 결정하는 것 -> 프로세스 동기화
- 상호배제 : 임계영역에 대한 동기화 문제 -> 다른 프로세스라도 순서 정해줘야함
(상호배제도 임계영역에 대한 동기화 문제로 볼 수 있음)

  <img width="450" alt="Screenshot 2024-03-16 at 11 04 48 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/10a2ec5b-4622-421a-9e1f-dc9b7c4499b3">

- ### 통신
- 프로세스들이 데이터를 공유하기 위해 반드시 필요 -> 프로세스간 통신(IPC)
- 통신방법
  - 하나의 __변수__ 사용
  - __메세지__ 를 서로 주고받음


## 세마포어
- 공유자원 접근 제한방법
- 상호배제와 동기화 문제를 해결하기 위한 도구
- __정수형 공용변수 s__ (프로세스 A,B가 같은 세마포어 쓸 수 있음)
  - 저장값 : 사용가능한 __자원의 수__ (변수 하나에 ready queue 하나가 할당) 또는 __잠김이나 풀림의 상태__ (임계영역에 들어갈 수 있는지/없는지)
- 상황에 맞춰 __0 이상인(양의 정수) 정수__ 로 __초기화__ 
- 두 기본연산(초기화연산) __P__ 와 __V__ 에 의해서만 사용됨 (s값에 초기 값을 부여하는 연산)
- 기본연산 : __인터럽트 되지 않고 하나의 단위로 처리__ 됨(중간에 끊기지 않음)
- 이진 세마포어 : 변수 s가 0 과 1 두종류의 값만 갖는 경우, Mutex라고 함, 프로세스간의 상호배제나 동기화를 목적으로 사용함
- 카운팅 세마포어 : s 가 0 이상의 정수 값을 가질 수 있음. 생산자-소비자 문제 등을 해결하기 위해 사용

  
<img width="630" alt="Screenshot 2024-03-16 at 11 10 03 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/ce8bb2bd-cdef-4cc4-902c-8cd2743e62e9">

- P 는 임계구역 들어가기 전에 수행하는 연산
- V 는 임계구역에서 나올 때 수행하는 연산
- s = 1 : 임계지역을 실행중인 프로세스 없음
- s = 0 : 임계지역을 실행중인 프로세스 있음
- 세마포어마다 대기 큐 필요

```
public synchronized void p(Semaphore s) {
    if (s > 0) {
        s--;
        // 프로세스 진행
    } else {
        // 현재 프로세스 대기
    }
}

public synchronized void v(Semaphore s) {
    if (existWaitingProcess()) {
        s++;
    } else {
        // 대기 프로세스 1개 진행
    }
}

```
- 만약 새로운 프로세스가 임계영역에 들어가기 위해 P 연산을 실행했는데 s 변수 값이 0 이라면, 프로세스를 block() 시키고, ready Queue 에 들어가 기다리게 만든다. (반복문으로 계속 체킹하는 busy waiting 현상없음) 임계 영역에 들어간 프로세스는 나올 때 큐에 있는 process 를 wake-up 시켜줄 것이다. 다만, semaphore queue 에 대한 wake-up 순서는 결정되지 않아 starvation 문제 발생 가능하다.


### 세마포어를 이용한 상호 배제 구현

조건 : 대기 큐 1개 필요
1. 진입영역 : 임계영역 수행 가능여부 체크 (조건 1) 
2. __임계영역__
3. 해제영역 : 다른 프로세스가 임계영역이 수행 가능하게 처리 (조건 2, 3) 

세마포어 mutex 초기값 : 1
1. 진입영역 : mutex--;
2. 임계영역 : 수행
3. 해제영역 : 대기큐 확인해서 프로세스 실행 (동기화) or 1로 수정

아래는 세마포어의 공용변수 mutex를 이용하여 상호배제를 구현한 수도코드.
``` 
public static int mutex = 1; // 세마포어 공용변수

... 

P(mutex);
임계영역();
v(mutex);
```


### 상호배제 해결
#### 상호배제를 위한 일반적인 요구사항
- 상호배제구현 필요성 : 한 프로세스가 임계영역 수행중 다른 프로스세는 임계영역에 진입해서는 안됨
- 동기화 필요성 :
  - 임계영역 수행중이던 프로세스가 임계영역 벗어나면 누군가 하나는 임계영역을 새로이 수행할 수 있어야 함 (임계영역 끝나는 시점 알려줄 필요 있음)
  - 임계영역 진입 못하고 대기하는 프로세스는 __적절한 시간 내__ 에 임게영역 수행을 시작할 수 있어야 함 (대기시간 너무 길어지면 공정성문제)

#### 상호배제 해결 
- 상호배제를 위한 임계영역 주변의 코드 영역

<img width="449" alt="Screenshot 2024-03-16 at 11 16 43 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/36735d6a-573b-4949-a3ce-42ad75281316"></br></br>

- 세마포어 이용

<img width="447" alt="Screenshot 2024-03-16 at 11 17 46 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/f976e9b1-8bcb-4ac5-a57f-d83807493037"></br></br>

<img width="552" alt="Screenshot 2024-03-16 at 11 32 08 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/7f075d5c-5bfd-43d6-93d1-4a667e77c1a3"></br></br>


동기화 해결

<img width="583" alt="Screenshot 2024-03-16 at 11 35 42 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/e330dc96-8bc8-4a6f-a1be-8fe36872069f"></br></br></br>
-> A, B 중 무엇이 먼저 들어와도 A가 먼저 처리되고 B 처리됨


---
# 병행 프로세스 2
## 생산자-소비자 문제 
### 생산자-소비자 문제 정의
- 두 __협력__ 프로세스 사이에 __버퍼__ 를 두고 생산자와 소비자의 상황을 다루는 문제
  - 생산자 : 버퍼에 데이터 넣는 프로세스
  - 소비자 : 버퍼에 데이터를 꺼내는 프로세스


<img width="336" alt="Screenshot 2024-03-16 at 11 41 00 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/837a1880-a793-4424-92d9-c1f7b226c017"></br></br>

### 생산자-소비자 문제 조건
- 버퍼에 여러 프로세스 __동시접근 불가능__
  - 버퍼에 넣을때 꺼낼 수 없음 / 꺼낼때 넣을 수 없음
-> __상호배제 필요__
- 버퍼의 크기가 유한(__유한__ 버퍼문제)
  - 버퍼가 가득차면 생산자 대기 필요
  - 버퍼 빈 경우 소비자 대기 필요
-> __동기화 필요__


### 세마포어를 이용한 해결
  
<img width="567" alt="Screenshot 2024-03-16 at 11 49 26 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/b0e68d7f-4fbe-4e5b-b114-b2574c1a7ae8"></br></br></br>

  
<img width="557" alt="Screenshot 2024-03-16 at 11 50 43 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/2dec23f4-a262-48fa-b603-55390baa8363"></br></br></br>

  
<img width="540" alt="Screenshot 2024-03-16 at 11 51 35 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/48461065-8ca3-4ad8-8eea-3f869074d826"></br></br></br>

  
<img width="478" alt="Screenshot 2024-03-16 at 11 51 49 AM" src="https://github.com/lenn-dev/TIL/assets/37726487/65373e12-a175-4e9e-9800-1af4d3e73eff"></br></br></br>


```
// 초기값 mutex = 1, empty = n, full = 0
// 생산자
while (true) {
    p(empty); // 버퍼 사용 가능여부 확인
    p(mutex)
    // 임계영역 진행 - 데이터 생산
    ...
    v(mutex);
    v(full);
}

//소비자
while (true) {
    p(full); // 버퍼 사용 가능여부 확인
    p(mutex)
    // 임계영역 진행 - 데이터 소비
    ...
    v(mutex);
    v(empty);
}

```

## 판독기-기록기 문제
### 판독기-기록기 문제 정의
여러 협력 프로세스 사이에 공유자원을 두고 판독기-기록기 상황을 다루는 문제
- 판독기 : 데이터 __읽는__ 프로세스 (공유자원에 아무런 영향 없음)
- 기록기 : 데이터 __쓰는__ 프로세스 (공유자원의 데이터가 변화됨)
이 개념으로 보면 생산자/소비자는 기록기 문제, 둘 다 버퍼의 __데이터를 변화__ 시키기 때문

### 판독기-기록기 문제 조건
- 하나의 기록기가 공유자원에 데이터를 쓰는 중 다른 기록기나 판독기는 공유자원에 접근 불가
  - 공유 자원에 데이터를 __쓰는 동안__ 에는 누구도 __접근불가__
  - 공유지원에 데이터를 __읽는 동안__ 에는 데이터를 쓸 수 __없음__
    (판독기가 읽는동안 기록기가 들어와 값을 바꿔버리면 변경된 값을 읽게 되는 상황발생)
-> __상호배제 필요__

- 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있음
  (읽기 판독기는 공유자원에 영향을 주지 않아 여러 판독기가 동시 수행 가능함)

- 하나의 기록기가 공유자원에 데이터를 쓰는 중에는 다른 기록기/판독기는 공유자원에 접근 불가능

- 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있음
  - 판독기가 읽는 중 새로는 판독기 읽기시도 가능
  - 판독기가 읽는 중 기록기 대기
  -> 새로운 판독기 읽기 시도 -> __가능/불가능__ 정책적 결정 필요


#### 제 1판독기-기록기 문제
- 판독기가 공유자원에 접근중이라면 기록기보다 __판독기에 우선순위__ 줌
- 즉, 새로운 판독기는 __즉시__ 공유자원 접근가능
- 문제점 : 기록기의 기아상태 유발 가능 (판독기가 우선순위가 있어서 새로운 판독기 작업이 계속 들어오는 경우 기록기 작업이 계속 뒤로 밀릴 수 있음 -> 세마포어로 해결가능)

```
// 기록기
p(writ);
// 임계영역 진행 - 데이터 기록
...
v(writ);

// 판독기
p(mutex);
rcount++;
if (rcount == 1) {
    p(wrt);
}
v(mutex);
// 임계영역 진행 - 데이터 판독
...
p(mutex);
rcount--;
if (rcount == 0) {
    v(wrt);
}
v(mutex);

```


#### 세마포어를 이용한 해결

<img width="466" alt="Screenshot 2024-03-16 at 12 06 36 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/3b2ee0e6-42a9-4b92-84a2-39c9e1922219"></br></br>

<img width="499" alt="Screenshot 2024-03-16 at 12 08 59 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/3fd58cda-5168-4feb-a58d-8ee3c114cb56"></br></br>

<img width="460" alt="Screenshot 2024-03-16 at 12 10 00 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1cc80635-a00b-47f0-8007-9a1a1cc84980"></br></br>


#### 제 2판독기-기록기 문제
- 판독기가 공유자원에 접근중이라면 판독기보다 기록기에 우선순위 줌
- 즉,대기중인 기록이 있다면 새로운 판독기는 공유자원에 접근 불가
- 문제점 : 판독기 병행성 떨어짐(판독기 읽는 중에 새 판독기 실행되는데 기록기 때문에 못 읽음), 판독기의 기아상태 유발 가능

```
public static int rd = 1;
public static int wrt = 1;
public static int mutex1 = 1;
public static int mutex2 = 1;
public static int mutex3 = 1;
public static int rcount = 1;
public static int wcount = 1;


// 기록기
p(mutex2);
wcount++;
if (wcount == 1) {
    p(rd);
}
v(mutex2);
p(wrt);
// 임계영역 진행 - 데이터 기록
v(wrt);
p(mutex2);
wcount--;
if (wcount == 0) {
    v(rd);
}
v(mutex2);

// 판독기
p(mutex3);
p(rd);
p(mutex1);
rcount++;
if (rcount == 1) {
    p(wrt);
}
v(mutex1);
v(rd);
v(mutex3);
// 임계영역 진행 - 데이터 판독
...
p(mutex1);
rcount--;
if (rcount == 0) {
    v(wrt);
}
v(mutex1);

```

#### 세마포어를 이용한 해결

<img width="661" alt="Screenshot 2024-03-16 at 12 13 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1890f20d-b40a-44c9-9f19-cea629b92bd7"></br></br>

## 프로세스간 통신
### 프로세스간 통신(IPC)
- InterProcess Communication
- 병행프로세스가 데이터를 서로 공유하는 방밥
  - 공유메모리 방법
  - 메시지 전달 방법
- 하나의 운영체제에서 두 방법 함꼐 사용 가능

### 공유 메모리 방법
- 협력 프로세스가 __동일한 변수__ 를 사용
  - 동일한 변수 : 공유자원인 메모리 공간 사용
- 예
  - 생산자-소비자 문제의 유한버퍼
  - 판독기-기록기 문제의 공유자원
- __대량 데이터 교환 -> 고속통신 가능__
- 통신상 발생 가능 문제 해결
  - 응용 프로그래머

### 메세지 전달방법
- 협력 프로세스가 메세지를 주고받음
  - 시스템 호출 send(), receive()
- __소량 데이터__ 교환에 적합
- 통신상 발생 가능 문제 해결
  - 운영체제 (운영체제가 알아서 해결해줌)

### 메세지 전달 방법의 논리적 구조
- 통신 링크
  - 메세지가 지나다니는 통로

- 통신링크의 구현 형태
  - 연결대상 : 두 프로세스/셋 이상 프로세스
  - 두 프로세스 사이 링크 개수 : 하나/둘이상
  - 방향성 : 단방향/양방향
  - 용량 : 무한/유한/0

### 통신 링크의 용량

<img width="498" alt="Screenshot 2024-03-16 at 12 17 45 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/c3a7b45f-8dac-4fd8-b966-5deec17c3ecd">
</br></br>

### 직접 통신

<img width="499" alt="Screenshot 2024-03-16 at 12 18 25 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ffd9e745-c67e-4212-af25-379c635842ad"></br></br>

<img width="488" alt="Screenshot 2024-03-16 at 12 18 55 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/fec1c7bd-4670-48e6-8ad8-d83970eef7cd"></br></br>

### 간접통신

<img width="482" alt="Screenshot 2024-03-16 at 12 19 25 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a317b0eb-c46f-4a7c-b0ac-8c672d2e899e"></br></br>

<img width="607" alt="Screenshot 2024-03-16 at 12 20 04 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/6c147ed0-5497-416b-91eb-6a14655aebde"></br></br>


# 교착상태 1
## 교착상태의 개요
- 교착 상태(膠着狀態) 또는 데드락(영어: deadlock): 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태이다. 전산학에서 교착 상태란 다중 프로그래밍 환경에서 흔히 발생할 수 있는 문제임.

## 교착상태의 특성
### 교착 상태의 조건
교착상태가 일어나려면 다음과 같은 네 가지 필요 조건을 충족시켜야 함.

- __상호배제(Mutual exclusion)__ :
  - 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구
  - 적어도 하나 이상의 자원은 여러 프로세스에 의해 동시 사용 불가능
  - 다른 프로세스가 점유한 자원이 필요하면 반드시 대기
- __점유대기(Hold and wait)__ : 프로세스가 이미 한 자원을 할당 받아 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는 또 다른 자원을 요구하여 해제되기를 기다리는 상황
- __비선점(No preemption)__ :
  - 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
  - 프로세스에 할당하는 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에는 해제되지 않음
- __순환대기, 환형대기(Circular wait)__ : 각 프로세스의 자원점유 및 자원요구단계가 환형을 이루며 대기하는 상황

이중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.

## 자원 할당 그래프 알고리즘(Resource-Allocation Graph Algorithm)

<img width="674" alt="Screenshot 2024-03-17 at 8 40 21 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/9d2b1dfe-df84-43a5-9a3f-399a50646b4c"></br></br>

<img width="587" alt="Screenshot 2024-03-17 at 8 41 48 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/9ee9bea5-a141-4b7d-a2ae-308e759a5a62"></br></br>

- 자원할당 그래프의 변화

<img width="572" alt="Screenshot 2024-03-17 at 8 46 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cbd42791-e655-492a-b62e-4247717f686f"></br></br>

- 자원할당 그래프

<img width="617" alt="Screenshot 2024-03-17 at 8 47 24 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/1eb0a524-9731-4d63-8ea9-ed8eb0fa942c"></br></br>

<img width="474" alt="Screenshot 2024-03-17 at 8 48 52 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/0cd8596d-f252-47c0-95f5-2b1b6ec28859"></br></br>

<img width="467" alt="Screenshot 2024-03-17 at 8 51 39 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f21bd73a-ec73-4b4f-861c-d91ddefee212"></br></br>


### 교착 상태의 처리기법 : 
- `예방`:교착상태의 네 가지 필요조건이 동시에 만족되는 것을 피하여 발생 예방
- `회피` : 프로세스에 필요한 자원의 최대량에 대한 정보를 이용하여 발생 회피
- `탐지 및 복구` : 발생 여부를 조사하여 발생한 경우에는 적절한 조치를 취해 정상상태로 복구하는 방법
  
## 교착 상태의 예방
### 1. 상호배제 조건의 제거
- 교착 상태는 두 개 이상의 프로세스가 공유가능한 자원을 사용할 때 발생하는 것이므로 공유 불가능한, 즉 상호 배제 조건을 제거하면 교착 상태를 해결할 수 있다.
- 공유 가능한 자원 : 상호배제 필요없음 (예: 읽기 전용파일)
- 공유 불가능 자원 : 반드시 상호배제 필요 (예: 프린트) -> 상호배제 조건 제거를 통한 교착상태 예방 불가능
  
### 2. 점유 대기 조건의 제거
- 자원을 점유했을 때 대기하지 않아야 함. 한 프로세스가 수행되기 전에 __모든 자원을 할당__ 시키고 나서 점유하지 않을 때에는 다른 프로세스가 자원을 요구하도록 하는 방법. 자원 과다 사용으로 인한 효율성, 프로세스가 요구하는 자원을 파악하는 데에 대한 비용, 자원이용률 낮아짐, 자원에 대한 내용을 저장 및 복원하기 위한 비용, 기아 상태, 무한대기 등의 문제점(한꺼번에 못받는 경우 생겨 계속 대기)
- 대기할 때 자원을 점유하고 있지 않아야 함. 새로운 자원 요구시 할당받았던 자원 모두 해제, __점유 도중 해제 불가능__ 한 자원에는 적용불가 (예: 플린터)

### 3. 비선점 조건의 제거
- 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 줌
  자원특성에 따라 불가능한 경우 존재 (예: 프린터)
- 다른 프로세스가 대기할 가능성 줄이기 : 점유대기 상황이 발생하면 할당받았던 자원을 모두 해제 ( 역시 프린터 같은 자원에는 적용 불가능)

### 4. 환형 대기 조건의 제거
자원 유형에 따라 순서를 매긴다.
이 교착 상태의 해결 방법들은 자원 사용의 효율성이 떨어지고 비용이 많이 드는 문제점이 있음

<img width="596" alt="Screenshot 2024-03-17 at 9 13 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/cfbaec74-75a2-4f54-af8d-21d849f44105">

<img width="623" alt="Screenshot 2024-03-17 at 9 15 06 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/e02ebcc1-9bc0-42db-8c0b-a99ec2a30440">

<img width="588" alt="Screenshot 2024-03-17 at 9 17 27 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/68d2ec24-9d09-45b7-bef6-b37fec1cff75">


# 교착상태 2
## 교착 상태 회피
- 데드락이 빠질 가능성이 있는지 없는지 운영체제가 검사하고 빠질 가능성이 없을 경우에만 자원을 할당함으로써 문제 발생을 피하는 방법
- 교착상태에 빠질 가능성을 판단하기 위해‘안전 상태’와 ‘불안전 상태’로 나눈다.
- 그리고 운영체제는 안전상태를 유지할 수 있는 요구만 수락해주고, 나머지 요구들은 안전상태를 만족할 때까지 계속 거절한다.
- 프로세스 자원 사용에 대한 사전정보를 제공하도록 요구하는 것으로 시스템에 circular wait가 발생하지 않도록 자원 할당 상태를 검사한다.
-  사전정보 : 현재 할당된 자원, 가용상태의 자원, 프로세스들의 최대 요구량

### 안전상태와 안전순서열 
- `안전상태` : 안전 순서열이 존재. 교착 상태 발생하지 않는 상태 
  교착상태를 회피하면서 각 프로세스에 그들의 최대 요구량 까지 빠짐없이 자원을 할당할 수 있는 상태
- `불안전 상태`  : 안전 순서열이 존재하지 않는 상태

- 안전상태를 계속 유지하면 교착상태를 회피할 수 있음

- `안전 순서열` : 순서있는 프로세스 집합<P1, P2,.......,Pn>
- 각 Pi에 대, Pi가 추가로 요구할 수 있는 자원의 양이 현재 가용상태의 자원으로 충당되거나 혹은 여기에 Pj(단 j<i)에 할당된 자원까지 포함하여 충당 가능한 경우

<img width="624" alt="Screenshot 2024-03-17 at 9 40 32 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/9600f478-a6e5-42d1-9cf3-60c254ee30b8"></br></br>

<img width="639" alt="Screenshot 2024-03-17 at 9 48 44 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/48266127-6243-4c0c-98fb-2263cb72964f"></br></br>

<img width="623" alt="Screenshot 2024-03-17 at 9 48 57 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/fc9e34cf-7df8-4d70-98f0-c8b9b203d0a5"></br></br>

### 교착상태 회피
- 교착상태는 `불안전상태`에서만 발생가능하므로 항상 `안전상태`를 유지해야함
- 프로세스의 가용상태의 자원을 요구하더라도 프로세스는 대기상태가 `될 수 있음`
- 자원이용율은 다소 낮아질 수 있음

  
### 교착 상태 회피하기 위한 두가지 알고리즘

#### __자원 할당 그래프 알고리즘__ (Resource Allocation Graph Algorithm) : 단위자원 하나뿐일 경우
- 변형된 자원할당 그래프 이용
  - 자원 정점에 표시하던 단위자원의 개수 제거
  - 선언간선(pi, rj)추가   pi -> rj 
    - 앞으로의 프로세스 pi 가 자원 rj를 요구하게 될 것임
    - 각각의 프로세스가 마칠때까지 추가적으로 요구될 가능성을 말함
    - 요구간선과 구분을 위해 점선으로 표기

- 자원을 __요구받으면__ 해당 선언간선을 __요구간선으로 변경__
- 그 요구간선을 할당간선으로 변환해도 __사이클이 생기지 않는 경우에만__ 자원을 할당하고 할당간선으로 변환

<img width="577" alt="Screenshot 2024-03-17 at 10 00 34 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/b281b316-4e5c-4861-9720-3eecd4c2b59c"></br></br>


#### __은행원 알고리즘__ (Banker's algorithm) : 각 자원의 단위자원이 여러개인 경우
- 은행원 알고리즘이 수행되기 위해서는 3가지가 필요하다.
1. MAX
  각 고객들이 얼마나 최대로 돈을 요구할지 = 각 프로세스가 자원을 최대로 얼마까지 요청할 수 있는지
2. Allocated
  각 고객들이 현재 빌린 돈이 얼마인지 = 각 프로세스가 현재 보유하고 있는 자원이 얼마인지
3. Available
  은행이 보유하고, 빌려줄 수 있는 돈은 얼마인지 = 시스템이 가용자원을 얼마나 보유하고 있는지
4. Need
  추가요구

<img width="608" alt="Screenshot 2024-03-17 at 10 15 55 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/58f622a6-c796-4573-805e-faf4b06dab02"></br></br>


<img width="620" alt="Screenshot 2024-03-17 at 10 57 16 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/f70a1710-b904-4291-b918-450b03351472">
</br></br>


- REQ1 =(1,1) 을 할당했을 경우를 계산해서 안전순서열이 존재하지 않아서 REQ1을 할당하지 않음
<img width="667" alt="Screenshot 2024-03-17 at 11 07 07 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/ab15ea75-691e-4455-b4fd-36be794f1d0a"></br></br>


- REQ3 할당할 경우를 먼저 계산했을 때 안전순서열이 존재함으로 할당해줌
<img width="630" alt="Screenshot 2024-03-17 at 11 10 18 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/66aeedef-1b0b-4772-967f-a1f15a03a4d8"></br></br>


## 교착상태 탐지 및 복구
### 교착상태 탐지
- 사후에 처리하는 방법 (이미 일어난 것에 대한 처리)
- 교착상태 탐지
  - 시스템의 교착상태 여부를 조사하기 위해 주기적으로 상태조사 알고리즘 수행
- 교착상태 복구
  - 교착상태가 탐지된 경우 적절한 조치를 취해 정상상태로 복구

<img width="587" alt="Screenshot 2024-03-17 at 11 26 06 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/19cec8c8-ca98-44f4-90f6-c8b5845fe1ff"></br></br>

<img width="583" alt="Screenshot 2024-03-17 at 11 28 09 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/a2f8af59-76b8-43b7-80c6-4d25ad8e732d"></br></br>

<img width="589" alt="Screenshot 2024-03-17 at 11 30 09 PM" src="https://github.com/lenn-dev/TIL/assets/37726487/335c323f-be54-4c51-8c69-5eae6263138a"></br></br>

### 교착상태 복구
- 교착상태가 탐지되면 복구 조치
- 복구의 주체
  - 오퍼레이터 : 수작업
  - 운영체제 : 자동
- 복구방법 : 
  - 1. 교착상태 __프로세스를 종료__
    - 모든 교착상태 프로세스를 종료방법 -> 단점: 진행했던 내용에 대한 복원비용이 큼
    - 사이클이 제거될 때까지 교착상태 프로세스를 하나씩 종료방법 -> 단점: 종료대상을 선택하기 위한 비용 매 프로세스 종료 후 교착상태 재확인을 위한 비용 (예: 여러개 사이클이 있을 경우에 여전히 교착상태)
  
  - 2. 교착된 프로세스가 __할당받은 자원을 해제__
    - 사이클이 제거될때까지 할당된 자원을 단계적으로 선범하여 다른 프로세스들에 할당
    - 프로세스와 자원 선택기준: 프로세스 진척도(5% vs 95% 작은것 선택해 해제), 사용중인 자원의 수 등
    - 프로세스의 복귀 시점도 제반 요소를 고려하여 결정 (5% or 10% 돌아갈건가?) 
    - 기아상태에 빠지지 않도록 프로세스 선택시 복구 횟수 고려


